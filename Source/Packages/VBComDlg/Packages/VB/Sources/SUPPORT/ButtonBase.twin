#If FEATURE_CHECKBOX Or FEATURE_OPTIONBUTTON Or FEATURE_COMMANDBUTTON Then
[InterfaceId("BAE0D7DF-237D-41F0-90C5-4DECC483D956")]
[COMCreatable(False)]
Private Class ButtonBase
    Inherits BaseControlFocusable
    
    [CustomDesigner("designer_SpectrumWindows")]
    [Description("")]
        Public BackColor As OLE_COLOR = VBRUN.SystemColorConstants.vb3DFace   ' FIXME this is linked to Appearance
    [CustomDesigner("designer_SpectrumWindows")]
    [Description("")]
        Public ForeColor As OLE_COLOR = VBRUN.SystemColorConstants.vbButtonText   ' FIXME this is linked to Appearance
    [Description("")]
        Public PictureDpiScaling As Boolean
    [Description("Only applicable to Graphical style buttons")]
        Public PictureAlignment As VBRUN.AlignConstants = VBRUN.AlignConstants.vbAlignTop
    [Description("Only applicable to Graphical style buttons.  When PictureAlignment is Left/Right, this affects the padding between the elements.  When PictureAlignment is Top/Bottom, this affects the padding between the text and the corresponding edge")]
        Public Padding As Long = 2      ' the default padding between the text and the bottom edge

    [Description("Opacity, given as a percentage, 0 - 100.  REQUIRES TARGET OS 6.2+ FOR CHILD CONTROLS.")]
        Public Opacity As Double = 100
        
    [CustomDesigner("designer_SpectrumWindowsOrClear")]
    [Description("A color, when set, that will appear fully transparent in the window.  REQUIRES TARGET OS 6.2+ FOR CHILD CONTROLS.")]
        Public TransparencyKey As OLE_COLOR = -1
        
    [Serialize(True, "DisabledPicture")]
    [CustomDesigner("designer_PictureBytes")]
        Protected ReadOnly DisabledPictureINIT() As Byte
    
    [Serialize(False)]
    Protected InternalDisabledPicture As StdPicture
    
    Sub New(ByVal ControlType As ControlTypeConstants)
       BaseControlFocusable.New(ControlType)
    End Sub
    
    [Serialize(False)]
    Public Property Get DisabledPicture() As StdPicture
        Return InternalDisabledPicture
    End Property

    [Serialize(False)]
    Public Property Set DisabledPicture(Value As StdPicture)
        Set InternalDisabledPicture = Value
        'PictureChanged()
    End Property

    [Serialize(False)]
    Public Property Let DisabledPicture(Value As StdPicture)    ' Weirdly, VBx also implements the Let for this
        Set InternalDisabledPicture = Value
        'PictureChanged()
    End Property
    
    [Serialize(True, "DownPicture")]
    [CustomDesigner("designer_PictureBytes")]
        Protected ReadOnly DownPictureINIT() As Byte
    
    [Serialize(False)]
    Protected InternalDownPicture As StdPicture
    
    [Serialize(False)]
    Public Property Get DownPicture() As StdPicture
    	Return InternalDownPicture
    End Property

    [Serialize(False)]
    Public Property Set DownPicture(Value As StdPicture)
        Set InternalDownPicture = Value
        'PictureChanged()
    End Property

    [Serialize(False)]
    Public Property Let DownPicture(Value As StdPicture)    ' Weirdly, VBx also implements the Let for this
        Set InternalDownPicture = Value
        'PictureChanged()
    End Property

    [Serialize(True, "Picture")]
    [CustomDesigner("designer_PictureBytes")]
       Protected ReadOnly PictureINIT() As Byte

    [Serialize(False)]
    Protected InternalPicture As StdPicture
    
    [Serialize(False)]
    Public Property Get Picture() As StdPicture
        Return InternalPicture
    End Property

    [Serialize(False)]
    Public Property Set Picture(Value As StdPicture)
        If Value Is Nothing Then Set Value = New StdPicture
        Set InternalPicture = Value
        'PictureChanged()
    End Property

    [Serialize(False)]
    Public Property Let Picture(Value As StdPicture)    ' Weirdly, VBx also implements the Let for this
        If Value Is Nothing Then Set Value = New StdPicture
        Set InternalPicture = Value
        'PictureChanged()
    End Property

        
    [CustomDesigner("designer_SpectrumWindows")]
    [Unimplemented]
        Public MaskColor As OLE_COLOR = &H00C0C0C0
    [Unimplemented]
        Public UseMaskColor As Boolean


    [Serialize(True, "!Style")]
        Public Style As VBRUN.ButtonConstants

    Protected FontHandle As LongPtr
    Protected InternalFont As StdFont
    
    Protected Sub InternalStateResetButton()
        If Me.FontHandle <> 0 Then GDI32.DeleteObject(Me.FontHandle)
        FontHandle = 0
        Set InternalFont = Nothing
        Set InternalDisabledPicture = Nothing
        Set InternalDownPicture = Nothing
        Set InternalPicture = Nothing
    End Sub

    Protected Sub InitializeButtonBase()
        CommonLoadPictureInit(Me.InternalPicture, Me.PictureINIT)
        CommonLoadPictureInit(Me.InternalDownPicture, Me.DownPictureINIT)
        CommonLoadPictureInit(Me.InternalDisabledPicture, Me.DisabledPictureINIT)
    End Sub
    
    Protected Sub SyncOLEFontHandle()
    	Dim OuterOwnerFont As Any = CType(Of StdFont)(GetInheritedOwner(Me).Font)
        'If Me.InternalFont IsNot OuterOwnerFont Then       ' font properties can change without changing the actual StdFont instance
            Set Me.InternalFont = OuterOwnerFont
        
            Dim ifont As Any = CType(Of IFont)(OuterOwnerFont)
            Dim LF As LOGFONT
            GDI32.GetObjectW(ifont.hFont, LenB(LF), LF)
            'LF.LFQuality = CByte(CLEARTYPE_QUALITY)
            
            If Me.FontHandle <> 0 Then GDI32.DeleteObject(Me.FontHandle)
            Me.FontHandle = GDI32.CreateFontIndirectW(LF)
        'End If
    End Sub
    
    Protected Function GetFontMetrics() As TEXTMETRIC
        RootWindowElementBase.CommonGetFontMetrics(CType(Of IFont)(GetInheritedOwner(Me).Font), GetFontMetrics)
    End Function
    
    Protected Sub HandleInitializeButton()
        Dim Opacity As Any = Me.Opacity
        If Opacity > 100 Then Me.Opacity = 100
        If Opacity < 0 Then Me.Opacity = 0
    End Sub
    
    Protected Sub HandleLoadButton()
        Dim Opacity As Any = Me.Opacity
        If ((Opacity >= 0) And (Opacity < 100)) Or (TransparencyKey <> -1) Then
            SyncOpacity
        End If
    End Sub
    
    Protected Sub SyncOpacity() _ 
            Handles Opacity.OnPropertyLet, _
                    TransparencyKey.OnPropertyLet
            
        RootWindowElementBase.RuntimeUIGetHandle().CommonSyncOpacity(Me.TransparencyKey, Me.Opacity)
    End Sub

    #If FEATURE_GRAPHICAL_BUTTONS Then
    Protected Sub HandleDrawItemBASE(ByRef Info As DRAWITEMSTRUCT, Handled As Boolean, _
                                    ByVal IsChecked As Boolean, ByVal IsCommandButton As Boolean)
            
        'Debug.Print Me.Name & ":" & CurrentProcedureName, "Info.ItemState: " & Hex(Info.ItemState)
        
        Dim InfoItemState As Any = Info.ItemState
        Dim InfoHDC As Any = Info.hDC
        Dim RootWindowElement As Any = Me.RootWindowElementBase
        Dim UnitPixelScale As Any = RootWindowElement.RuntimeUIGetUnitScale()
        Dim PictureAlignment As Any = Me.PictureAlignment
        
        Dim backColor As Long = TranslateColor(Me.BackColor)
        Dim brush As LongPtr
                                
            Dim IsSelected As Boolean = InfoItemState And OwnerDrawState.ODS_SELECTED

            If IsChecked Then
                brush = CreateCheckeredPatternBrush(InfoHDC, vbWhite, backColor)
                IsSelected = True
            Else
                brush = GDI32.CreateSolidBrush(backColor)
            End If
                        
            Dim rect As tbRECT
            rect.Right = RootWindowElement.RuntimeUIGetCurrentWidth()
            rect.Bottom = RootWindowElement.RuntimeUIGetCurrentHeight()

            If (rect.Right > rect.Left) And (rect.Bottom > rect.Top) Then
                Dim OuterOwner As Object = GetInheritedOwner(Me)
                Dim actualForeColor As Long = TranslateColor(If(OuterOwner.Enabled, Me.ForeColor, vbGrayText))
                Dim oldTextColor As Long = InfoHDC.SetTextColor(actualForeColor)
                Dim oldBkMode As Long = InfoHDC.SetBkMode(1)
                                
                Dim picture As OlePicture = Me.Picture
                If IsSelected Then
                    Dim downPicture	As Any = Me.DownPicture
                    If ((downPicture IsNot Nothing) AndAlso (downPicture.Handle <> 0)) Then Set picture = CType(Of OlePicture)(downPicture)
                ElseIf InfoItemState And OwnerDrawState.ODS_DISABLED Then
                    Dim disabledPicture As Any = Me.DisabledPicture
                    If ((disabledPicture IsNot Nothing) AndAlso (disabledPicture.Handle <> 0)) Then Set picture = CType(Of OlePicture)(disabledPicture)
                End If
                
                Dim pictureIsEmpty As Boolean = ((picture Is Nothing) OrElse (picture.Handle = 0))
                
                Dim extraPadding As Long = CLng(Me.Padding * UnitPixelScale)
                If Len(OuterOwner.Caption) = 0 Or (pictureIsEmpty) Or (PictureAlignment = vbAlignNone) Then
                    extraPadding = 0
                End If
                
                If IsCommandButton = True Then
                    If InfoItemState And OwnerDrawState.ODS_FOCUS Then
                        If (rect.Right > 2) And (rect.Bottom > 2) Then
                            Dim pen As LongPtr = GDI32.CreatePen(PS_SOLID, 1, vbBlack)
                            Dim oldPen As LongPtr = InfoHDC.SelectObject(pen)
                            InfoHDC.Rectangle(0, 0, rect.Right, rect.Bottom)
                            InfoHDC.SelectObject(oldPen)
                            
                            rect.Left += 1
                            rect.Top += 1
                            rect.Right -= 1
                            rect.Bottom -= 1
                        End If
                    End If
                End If
                
                Dim bfStyle As Long
                Dim bfFlags As Long = BorderFlags.BF_RECT Or BorderFlags.BF_ADJUST
                                    
                If IsSelected Then
                    bfStyle = BorderStyles.BDR_SUNKENOUTER Or BorderStyles.BDR_SUNKENINNER
                Else
                    bfStyle = BorderStyles.BDR_RAISEDOUTER Or BorderStyles.BDR_RAISEDINNER
                End If
                    
                InfoHDC.DrawEdge(rect, bfStyle, bfFlags)
                                                
                If brush <> 0 Then
                    InfoHDC.FillRect(rect, brush)
                End If

                ' Even if not focused, calculate positions as if we were focused so that if we do become
                ' focused, the aligned position of text is not affected by the outer focus rectangle
                If IsCommandButton = True Then
                    If (InfoItemState And OwnerDrawState.ODS_FOCUS) = 0 Then
                        If (rect.Right - rect.Left) > 2 Then
                            rect.Left += 1
                            rect.Right -= 1
                        End If
                        If (rect.Bottom - rect.Top) > 2 Then
                            rect.Top += 1
                            rect.Bottom -= 1
                        End If
                    End If
                End If
                                                                    
                SyncOLEFontHandle()
                
                Dim oldFont As LongPtr = InfoHDC.SelectObject(Me.FontHandle)
                

                Dim DrawWidth As Long
                Dim DrawHeight As Long
                Dim RecalculatedRenderPath As Boolean = False
            ReCalcRenderPath:
                Dim maxWidth As Long = rect.Right - rect.Left
                Dim offsetTop As Long = 0
                Dim offsetLeft As Long = 0
                Dim remainingHeight As Long = (rect.Bottom - rect.Top)
                
                If (picture IsNot Nothing) Then
                
                    Dim pictureType As Any = CType(Of PictureTypeConstants)(picture.Type)
                    Dim pictureWidth As Any = picture.Width
                    Dim pictureHeight As Any = picture.Height
                    
                    Const PICTYPE_METAFILE As Long = 2
                    Const PICTYPE_ENHMETAFILE As Long = 4
                    If (pictureType = PICTYPE_METAFILE) Or (pictureType = PICTYPE_ENHMETAFILE) Then
                        ' this will size to fit later
                    Else
                        ScaleOLEPictureDimensionsToPixels(pictureType, pictureWidth, DrawWidth, pictureHeight, DrawHeight)
                        If PictureDpiScaling = True Then
                            DrawWidth = CLng(DrawWidth * UnitPixelScale)
                            DrawHeight = CLng(DrawHeight * UnitPixelScale)
                        End If
                    End If
                    
                    If (PictureAlignment = vbAlignLeft) Or (PictureAlignment = vbAlignRight) Then
                        maxWidth -= DrawWidth + extraPadding
                        If maxWidth < 0 Then maxWidth = 0
                    
                        If PictureAlignment = vbAlignLeft Then
                            offsetLeft += DrawWidth + extraPadding
                        End If
                    End If
                End If
                
                ' FIXME we should cache the render path                             
                Dim textRender As TextRenderPath = New TextRenderPath(InfoHDC, CStr(OuterOwner.Caption), True, AlignmentConstants.vbCenter, maxWidth, False, False, 0)
                remainingHeight -= textRender.TotalHeight
                
                If (pictureIsEmpty) Or (PictureAlignment = vbAlignNone) _
                        Or (PictureAlignment = vbAlignLeft) _
                        Or (PictureAlignment = vbAlignRight) Then
                    offsetTop = CLng(Int(remainingHeight / 2))
                ElseIf PictureAlignment = vbAlignBottom Then
                    offsetTop = extraPadding
                ElseIf PictureAlignment = vbAlignTop Then
                    offsetTop = ((rect.Bottom - extraPadding) - textRender.TotalHeight) - rect.Top
                End If
                
                remainingHeight -= extraPadding
                
                ' When selected (down), the content is shifted 1x1 pixels
                Dim picOffsetXY As Long
                If IsSelected Then
                    picOffsetXY = 1
                    offsetLeft += 1
                    offsetTop += 1
                End If
                            
                If picture IsNot Nothing Then
                    If (pictureType = PICTYPE_METAFILE) Or (pictureType = PICTYPE_ENHMETAFILE) Then
                        ' size to fit (VBx doesn't do this)
                        If (PictureAlignment = vbAlignLeft) Or (PictureAlignment = vbAlignRight) Then
                            If RecalculatedRenderPath = False Then
                                Dim remainingWidth As Long = (rect.Right - rect.Left) - (textRender.TotalWidth + extraPadding)
                                If remainingWidth > 0 Then
                                    DrawWidth = remainingWidth
                                    DrawHeight = CLng((pictureHeight / pictureWidth) * remainingWidth)
                                    RecalculatedRenderPath = True
                                    GoTo ReCalcRenderPath
                                End If
                            End If
                        Else
                            If remainingHeight > 0 Then
                                If remainingHeight > 6 Then
                                    ' allow for some padding around the picture
                                    remainingHeight -= 6
                                End If
                                DrawWidth = CLng((pictureWidth / pictureHeight) * remainingHeight)
                                DrawHeight = remainingHeight
                            End If
                        End If
                    End If
                    
                    Const STRETCH_HALFTONE = 4
                    Dim OldStretchMode As Long = InfoHDC.SetStretchBltMode(STRETCH_HALFTONE)
                    InfoHDC.SetBrushOrgEx(0, 0, 0)

                    If (DrawWidth > 0) And (DrawHeight > 0) Then
                                                    
                        ' The text gets drawn OVER the image if necessary, so image must be drawn first
                        ' Calculate the vertical mid-point of the remaining space, after taking into account the text height
                        
                        Dim picX As Long = picOffsetXY + rect.Left
                        Dim picY As Long = picOffsetXY + rect.Top
                        Dim thisWidth As Any = rect.Right - rect.Left
                        Dim thisHeight As Any = rect.Bottom - rect.Top
                        Dim textRenderTotalWidth As Any = textRender.TotalWidth
                        Dim textRenderTotalHeight As Any = textRender.TotalHeight
                        
                        Dim additionX As Long
                        Dim additionY As Long
                        
                        Dim extra As Long
                        If PictureAlignment = vbAlignRight Then
                            extra = extraPadding + textRender.TotalWidth
                        ElseIf PictureAlignment = vbAlignBottom Then
                            extra = textRenderTotalHeight + extraPadding
                        End If
                        
                        If (PictureAlignment = vbAlignLeft) Or (PictureAlignment = vbAlignRight) Then
                            additionX = CLng(Int(((thisWidth) - (textRenderTotalWidth + DrawWidth) - extraPadding) / 2) + extra)
                            additionY = CLng(Int(((thisHeight) - DrawHeight) / 2))
                        ElseIf (PictureAlignment = vbAlignTop) Or (PictureAlignment = vbAlignBottom) Then
                            additionX = CLng(Int((thisWidth) / 2) - Int(DrawWidth / 2))
                            additionY = CLng(Int(remainingHeight / 2) - Int(DrawHeight / 2) + extra)
                        ElseIf PictureAlignment = vbAlignNone Then
                            additionX = CLng(Int((thisWidth) / 2) - Int(DrawWidth / 2))
                            additionY = CLng(Int((thisHeight) / 2) - Int(DrawHeight / 2))
                        End If
                        
                        picX += additionX
                        picY += additionY
                        
                        Dim hrgn As LongPtr = GDI32.CreateRectRgn(rect.Left, rect.Top, rect.Right, rect.Bottom)
                        Dim oldClipRgn As LongPtr = InfoHDC.SelectClipRgn(hrgn)
                        PictureRender(picture, InfoHDC, picX, picY, DrawWidth, DrawHeight)
                        InfoHDC.SelectClipRgn(oldClipRgn)
                    End If
                    InfoHDC.SetStretchBltMode(OldStretchMode)
                End If
            
                If textRender.HasMnemomnics Then
                    textRender.RenderWithMnemonics(InfoHDC, rect, offsetLeft, offsetTop, GetFontMetrics().TMAscent, UnitPixelScale, False)
                Else
                    textRender.Render(InfoHDC, rect, offsetLeft, offsetTop, False)
                End If
                
                If (InfoItemState And OwnerDrawState.ODS_FOCUS) And ((InfoItemState And OwnerDrawState.ODS_NOFOCUSRECT) = 0) Then

                    Dim focusRectOffset As Long = 1
                    If IsCommandButton = True Then
                        If (rect.Right > 2) And (rect.Bottom > 2) Then
                        	focusRectOffset = 1
                        End If
                    Else
                        If (rect.Right > 4) And (rect.Bottom > 4) Then
                            focusRectOffset = 2
                        End If
                    End If
                    
                    If focusRectOffset <> 0 Then
                        rect.Left += focusRectOffset
                        rect.Top += focusRectOffset
                        rect.Right -= focusRectOffset
                        rect.Bottom -= focusRectOffset
                        
                        Dim oldForeColor As Long = InfoHDC.SetTextColor(vbBlack)        ' important to ensure the focus rect appears dotted
                        Dim oldBkColor As Long = InfoHDC.SetBkColor(vbWhite)            ' important to ensure the focus rect appears dotted
                        InfoHDC.DrawFocusRect(rect)
                        InfoHDC.SetTextColor(oldForeColor)
                        InfoHDC.SetBkColor(oldBkColor)
                    End If
                End If
                
                                            
                
            ' Debug.Print "---------------------------------"
                
                InfoHDC.SetBkMode(oldBkMode)
                InfoHDC.SetTextColor(oldTextColor)
                InfoHDC.SelectObject(oldFont)
            
            End If
            
        Handled = True     ' swallow up the event

        If brush <> 0 Then GDI32.DeleteObject(brush)
        
    End Sub
    #End If
    
    Protected Sub ColorsChanged() _
                Handles BackColor.OnPropertyLet, _
                        ForeColor.OnPropertyLet

        GetInheritedOwner(Me).Refresh
    End Sub
    
    Protected Sub Class_Terminate()
    	Dim FontHandle As Any = Me.FontHandle
        If FontHandle <> 0 Then GDI32.DeleteObject(FontHandle)
        Me.FontHandle = 0
    End Sub
    
    Protected Sub SyncRecreate() _
            Handles Style.OnPropertyLet
            
        SelfRecreate()
    End Sub
    
    Overridable Protected Sub SelfRecreate()
    End Sub

End Class
#End If