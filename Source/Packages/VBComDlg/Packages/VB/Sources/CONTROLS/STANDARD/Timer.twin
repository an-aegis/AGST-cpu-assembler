#If FEATURE_TIMER Then
[ClassId("9AC3404A-6793-4D0B-88B7-1C9834DB8B6D")]
[InterfaceId("CC551BE2-37E0-4483-81E7-F786EDD7FF13")]    ' FIXME implement {33AD4F29-6699-11CF-B70C-00AA0060D393} for backcompat
[COMCreatable(False)]
[EventsUseDispInterface]
[ComImport(True)]
Private Class TimerBaseCtl
    
    #Region "INHERITANCE"
 
        Inherits BaseControlNotFocusable
    
        [WithDispatchForwarding] Implements Control
        Implements IWindowsControl

    #End Region
        
    #Region "STATE"
    
        [Description("")]
        [Serialize(True, "Interval")]
            Protected IntervalINIT As Long = 0
        [Description("")]
        [Serialize(True, "Enabled")]
            Protected EnabledINIT As Boolean = True

            Protected InternalTimerId As LongPtr
            Protected InternalInterval As Long
            
    #End Region

    #Region "EVENTS"
    
        [DefaultDesignerEvent]
        [Description("")]
            Event Timer()
    
    #End Region
               
    #Region "MEMBERS"
        Sub New()
            BaseControlNotFocusable.New(ControlTypeConstants.vbTimer)
        End Sub
    
        Protected Sub HandleInitialize(ByVal ControlContext As ControlContext) _
            Implements IWindowsControl.Initialize
            
            Me.InternalStateResetRect()     ' resets all the base class state()
            
            Dim SerializeInfo As Any = ControlContext.RuntimeUICtxGetSerializer()
            
            If Not SerializeInfo.RuntimeUISrzDeserialize(Me) Then
                'Caption_INIT = "Timer"
            End If
            'MsgBox Me.PixelsLeft
            'IsDesignMode = .IsDesignMode
            
            Dim InitData As WindowCreationData
            InternalBaseControlBeforeCreateRootWindow(InitData)
            InternalBaseControlInfo.WindowlessEnabled = EnabledINIT
            ControlContext.RuntimeUICtxSetBaseControlInfoPtr(VarPtr(InternalBaseControlInfo))
            
            Me.Initialize(ControlContext)
            
            ControlContext.RuntimeUICtxSetControlArrayIndex(InternalBaseControlInfo.ControlArrayIndex)
            
            InternalTimerId = ControlContext.RuntimeUICtxCreateTimer(AddressOf Me.OnTimer)
            InternalInterval = IntervalINIT
            Me.InternalHandleChangedTimer()
        End Sub
        
        Protected Sub HandleDestroy() _
            Implements IWindowsControl.Destroy

            #If LOG_TERMINATE Then
                Debug.Print CurrentComponentName & "." & CurrentProcedureName
            #End If
            ' disconnect anything that causes a circular reference here
            [_HiddenModule].ResetFirstMethodAccessFlag([_HiddenModule].GetInheritedOwner(Me))
        End Sub

        #If LOG_TERMINATE Then
            Protected Sub Class_Terminate()
                Debug.Print CurrentComponentName & "." & CurrentProcedureName
            End Sub
        #End If
        
        Protected Sub InternalHandleChangedTimer()
        	RuntimeUITimerChangeProps(InternalTimerId, InternalInterval, InternalBaseControlInfo.WindowlessEnabled)
        End Sub
        
        [Serialize(False)]
        [DefaultMember]
        Public Property Get _Default() As Boolean
            Return Me.Enabled
        End Property
        
        [Serialize(False)]
        [DefaultMember]
        Public Property Let _Default(ByVal Value As Boolean)
            Me.Enabled = Value      ' FIXME does this actually trigger HandleChangedTimer? probably not, as we are calling from the internal interface
        End Property
        
        [Serialize(False)]
        Public Property Get Interval() As Long
            Return Me.InternalInterval
        End Property
        
        [Serialize(False)]
        Public Property Let Interval(ByVal Value As Long)
            If Value < 0 Then
                Err.Raise 380, , "Invalid property value"
            End If
            Me.InternalInterval = Value
            Me.InternalHandleChangedTimer()
        End Property
        
        [Serialize(False)]
        Public Property Get Parent() As Object ' As Form  FIXME, needs to work also for UCs
            Return ControlContext.RuntimeUICtxEnsureGetForm()
        End Property

        [Serialize(False)]
        Public Property Get Enabled() As Boolean
            Return InternalBaseControlInfo.WindowlessEnabled
        End Property
    
        [Serialize(False)]
        Public Property Let Enabled(ByVal Value As Boolean)
            InternalBaseControlInfo.WindowlessEnabled = Value
            Me.InternalHandleChangedTimer()
        End Property
        
        Public Sub OnTimer()            ' FIXME this should be PROTECTED
            RaiseEvent Timer
        End Sub
        
    #End Region

End Class

[Description("A Win32 native Timer")]
[WindowsControl("/miscellaneous/ICONS??/Timer??.png")]
[ClassId("33AD4F28-6699-11CF-B70C-00AA0060D393")]
[InterfaceId("CBF980C9-52E5-41E8-A1FF-CA3BD890F8F8")]    ' FIXME implement {33AD4F29-6699-11CF-B70C-00AA0060D393} for backcompat
[COMCreatable(False)]
[EventsUseDispInterface]
[ComImport(True)]
Class Timer
    Inherits TimerBaseCtl
    
    Protected Sub Class_BeforeFirstMethodAccess()
        [_HiddenModule].EnsureContainerIsLoaded(Me)
    End Sub
End Class
#End If