#If FEATURE_SLIDER Then
[ClassId("E230FE4A-69F5-415D-A6FD-4EB543CCE0F6")]
[InterfaceId("26F7602C-09A4-4CDB-9B9E-F81737D26BA6")]
[COMCreatable(False)]
[EventsUseDispInterface]
Class SliderBaseCtl
	
	#Region "INHERITANCE"

        Inherits VB.BaseControlFocusableNoFont
        
        [WithDispatchForwarding] Implements Control
        Implements VB.IWindowsControl
        Implements VB.IWindowElementEventsCommon
        Implements VB.IWindowElementEventsCommonControls
        Implements VB.IWindowElementEventsUC
        Implements VB.IWindowElementEventsAX
        Implements VB.IWindowElementEventsGraphics
        
    #End Region
            
    #Region "STATE"
        Enum TickStyleConstants
            sldBottomRight = 0
            sldTopLeft = 1
            sldBoth = 2
            sldNoTicks = 3
        End Enum

        Enum TextPositionConstants
            sldAboveLeft = 0
            sldBelowRight = 1
        End Enum
            
        [Description("")]
            Public BorderStyle As VBRUN.ControlBorderStyleConstants = ControlBorderStyleConstants.vbNoBorder
        
        [CustomDesigner("designer_SpectrumWindows")]
        [Description("")]
            Public BackColor As OLE_COLOR = VBRUN.SystemColorConstants.vbButtonFace

        #If FEATURE_OLEDRAGDROP Then
        [CustomDesigner("designer_RestrictedOLEDropMode")]
            Public OLEDropMode As VBRUN.OLEDropConstants
        Protected OLEDragDropHandler As VB.OLEDragDropHandler
        #End If
            
        [Description("Opacity, given as a percentage, 0 - 100.  REQUIRES TARGET OS 6.2+ FOR CHILD CONTROLS.")]
            Public Opacity As Double = 100
        
        [CustomDesigner("designer_SpectrumWindowsOrClear")]
        [Description("A color, when set, that will appear fully transparent in the window.  REQUIRES TARGET OS 6.2+ FOR CHILD CONTROLS.")]
            Public TransparencyKey As OLE_COLOR = -1
                
        [CustomDesigner("designer_MultiLineText")]
        [Serialize(True, "ToolTipText")]
            Protected ToolTipTextINIT As String

        [Serialize(True, "Min")]
            Protected Min_INIT As Long = 0
        [Serialize(True, "Max")]
            Protected Max_INIT As Long = 10
        [Serialize(True, "Value")]
            Protected Value_INIT As Long = 0
        [Serialize(True, "SelStart")]
            Protected SelStart_INIT As Long = 0
        [Serialize(True, "SelLength")]
            Protected SelLength_INIT As Long = 0
        [Serialize(True, "SmallChange")]
            Protected SmallChange_INIT As Long = 1
        [Serialize(True, "LargeChange")]
            Protected LargeChange_INIT As Long = 2
            
            Protected IsInitialized As Boolean
            Protected InternalRangeStart As Long
        
            Public HideThumb As Boolean = False
            Public ShowTip As Boolean = True
            Public SelectRange As Boolean = False
            Public TickFrequency As Long = 1
            Public TextPosition As TextPositionConstants = TextPositionConstants.SldAboveLeft
            Public TickStyle As TickStyleConstants = TickStyleConstants.SldBottomRight
            Public Orientation As OrientationConstants = OrientationConstants.ccOrientationHorizontal
            
        [Serialize(True, "VisualStyles")]
            Protected VisualStylesINIT As Boolean = True
            
            Protected IsDesignMode As Boolean

    #End Region

    #Region "EVENTS"
    
        [Description("")]
            Event Change()
        [DefaultDesignerEvent]
        [Description("")]
            Event Click()
        [Description("")]
            Event GotFocus()
        [Description("")]
            Event KeyDown(KeyCode As Integer, Shift As Integer)
        [Description("")]
            Event KeyPress(KeyAscii As Integer)
        [Description("")]
            Event KeyUp(KeyCode As Integer, Shift As Integer)
        [Description("")]
            Event LostFocus()
        [Description("")]
            Event MouseDown(Button As Integer, Shift As Integer, X As Single, Y As Single)
        [Description("")]
            Event MouseMove(Button As Integer, Shift As Integer, X As Single, Y As Single)
        [Description("")]
            Event MouseUp(Button As Integer, Shift As Integer, X As Single, Y As Single)
        [Description("")]
            Event Initialize()
        [Description("")]
            Event DragDrop(Source As Control, X As Single, Y As Single)
        [Description("")]
            Event DragOver(Source As Control, X As Single, Y As Single, State As Integer)
        Event OLECompleteDrag(Effect As Long)
        Event OLEDragDrop(Data As DataObject, Effect As Long, Button As Integer, Shift As Integer, X As Single, Y As Single)
        Event OLEDragOver(Data As DataObject, Effect As Long, Button As Integer, Shift As Integer, X As Single, Y As Single, State As Integer)
        Event OLEGiveFeedback(Effect As Long, DefaultCursors As Boolean)
        Event OLESetData(Data As DataObject, DataFormat As Integer)
        Event OLEStartDrag(Data As DataObject, AllowedEffects As Long)
        [Description("")]
            Event Scroll()
        Event Validate(Cancel As Boolean)
        
    #End Region
               
    #Region "MEMBERS"
        Sub New()
            BaseControlFocusableNoFont.New(ControlTypeConstants.vbSlider)
        End Sub
    
        Protected Sub HandleLoad() _
                Implements VB.IWindowElementEventsCommon.Load
            
            Dim Opacity As Any = Me.Opacity
            If ((Opacity >= 0) And (Opacity < 100)) Or (TransparencyKey <> -1) Then
                SyncOpacity
            End If
        End Sub
        
        Protected Sub SyncOpacity() _ 
                Handles Opacity.OnPropertyLet, _
                        TransparencyKey.OnPropertyLet
            
            RootWindowElementBase.RuntimeUIGetHandle().CommonSyncOpacity(Me.TransparencyKey, Me.Opacity)
        End Sub
        
        Protected Sub HandleInitialize(ByVal ControlContext As VB.ControlContext) _
                Implements VB.IWindowsControl.Initialize
            
            Me.InternalStateResetRectDockable()     ' resets all the base class state
            Me.IsInitialized = False
            
            Dim SerializeInfo As Any = ControlContext.RuntimeUICtxGetSerializer()
            
            If Not SerializeInfo.RuntimeUISrzDeserialize(Me) Then
                If Me.PixelsHeight > Me.PixelsWidth Then
                    Me.Orientation = OrientationConstants.ccOrientationVertical
                End If
            End If
            IsDesignMode = SerializeInfo.RuntimeUISrzIsDesignMode()
            
            With InternalBaseControlInfo
                .NamePtr = VarPtr(Me.NameINIT)
                .ToolTipText = Me.ToolTipTextINIT
                .VisualStyles = Me.VisualStylesINIT
            End With
            
            Dim Opacity As Any = Me.Opacity
            If Opacity > 100 Then Me.Opacity = 100
            If Opacity < 0 Then Me.Opacity = 0
                
            Dim InitData As VB.WindowCreationData
            InitData.WindowAtomIdx = CInt(VB.EnumWindowAtoms.AtomIdx_ThunderSlider)
            InitData.WindowStyles = GetStyles()
            InitData.SubClass = True
            CreateRootWindowElement(ControlContext, InitData)
            RootWindowElementBase.RuntimeUISetAndSinkEvents(Me)
        End Sub
        
        Protected Function GetStyles() As Long
            Dim Styles As Long
        	Styles += If(HideThumb, TBS_NOTHUMB, 0&)
            Styles += If(ShowTip, TBS_TOOLTIPS, 0&)
            Styles += If(SelectRange, TBS_ENABLESELRANGE, 0&)
            Styles += TBS_AUTOTICKS
            Styles += If(Orientation = OrientationConstants.ccOrientationHorizontal, TBS_HORZ, TBS_VERT)
            Styles += If(BorderStyle = ControlBorderStyleConstants.vbFixedSingleBorder, VB.WS_BORDER, 0&)

            Select Case TickStyle
                Case TickStyleConstants.sldBottomRight
                    If Orientation = Orientation.ccOrientationHorizontal Then
                        Styles += TBS_BOTTOM
                    Else
                        Styles += TBS_RIGHT
                    End If
                Case TickStyleConstants.sldTopLeft
                    If Orientation = Orientation.ccOrientationHorizontal Then
                        Styles += TBS_TOP
                    Else
                        Styles += TBS_LEFT
                    End If
                Case TickStyleConstants.sldBoth
                    Styles += TBS_BOTH
                Case Else
                    Styles += TBS_NOTICKS
            End Select
            
            Return Styles
        End Function
                
        Protected Sub HandleDestroy() _
                Implements VB.IWindowsControl.Destroy
            #If LOG_TERMINATE Then
                Debug.Print CurrentComponentName & "." & CurrentProcedureName
            #End If
            
            ' disconnect anything that causes a circular reference here
            #If FEATURE_OLEDRAGDROP Then
            If OLEDragDropHandler IsNot Nothing Then OLEDragDropHandler.Disconnect()
            #End If
            
            [_HiddenModule].ResetFirstMethodAccessFlag([_HiddenModule].GetInheritedOwner(Me))
        End Sub

        #If LOG_TERMINATE Then
            Protected Sub Class_Terminate()
                Debug.Print CurrentComponentName & "." & CurrentProcedureName
            End Sub
        #End If
        		
        Protected Sub HandleCreate() _
                Implements VB.IWindowElementEventsCommon.Create

            Me.Min = Min_INIT
            Me.Max = Max_INIT
            Me.Value = Value_INIT
            Me.SelStart = SelStart_INIT
            Me.SelLength = SelLength_INIT
            Me.SmallChange = SmallChange_INIT
            Me.LargeChange = LargeChange_INIT

            SyncTickFrequency ()
            SyncTextPosition ()
            
            #If FEATURE_OLEDRAGDROP Then
            SyncOLEDropMode ()
            #End If
            RaiseEvent Initialize()
            
            IsInitialized = True
        End Sub
        
        Protected Sub HandleMouseDown(ByVal Button As VBRUN.MouseButtonConstants, _
                                        ByVal ShiftState As VBRUN.ShiftConstants, _
                                        ByVal X As Single, ByVal Y As Single, ByRef SwallowMessage As Boolean) _
                Implements VB.IWindowElementEventsCommon.PreMouseDown
            
            'BeginMouseCapture(RootWindowElement)   this intereferes with dragging the slider
            RaiseEvent MouseDown(CInt(Button), CInt(ShiftState), X, Y)
        End Sub
        
        Protected Sub HandleMouseMove(ByVal Button As VBRUN.MouseButtonConstants, _
                                        ByVal ShiftState As VBRUN.ShiftConstants, _
                                        ByVal X As Single, ByVal Y As Single) _
                Implements VB.IWindowElementEventsCommon.MouseMove
                
            RaiseEvent MouseMove(CInt(Button), CInt(ShiftState), X, Y)
        End Sub
        
        Protected Sub HandleMouseUp(ByVal Button As VBRUN.MouseButtonConstants, _
                                    ByVal ShiftState As VBRUN.ShiftConstants, _
                                    ByVal X As Single, ByVal Y As Single, ByRef SwallowMessage As Boolean) _
                Implements VB.IWindowElementEventsCommon.PreMouseUp
                
            Dim ScaledPixX As Double = (X / ControlContext.RuntimeUICtxGetScaleModePixelsMultiplierX())
            Dim ScaledPixY As Double = (Y / ControlContext.RuntimeUICtxGetScaleModePixelsMultiplierY())
            
            RaiseEvent MouseUp(CInt(Button), CInt(ShiftState), X, Y)
            
            'If EndMouseCapture() Then
                If IsInRect(ScaledPixX, ScaledPixY) Then
                    RaiseEvent Click()
                End If
            'End If
        End Sub
        
        Protected Sub HandleGotFocus() _
                Implements VB.IWindowElementEventsUC.GotFocus
              
            If IsInitialized = True Then
                RaiseEvent GotFocus()
            End If
        End Sub

        Protected Sub HandleLostFocus() _
                Implements VB.IWindowElementEventsUC.LostFocus
                
            RaiseEvent LostFocus()
        End Sub
        
        Protected Sub HandleKeyDown(ByRef KeyCode As VBRUN.KeyCodeConstants, _
                                    ByVal ShiftState As VBRUN.ShiftConstants) _
                Implements VB.IWindowElementEventsCommon.KeyDown
        
            Dim KeyCodeInt As Integer = CInt(KeyCode)
            RaiseEvent KeyDown(KeyCodeInt, CInt(ShiftState))
            KeyCode = CType(Of VBRUN.KeyCodeConstants)(KeyCodeInt)
        End Sub
        
        Protected Sub HandleKeyUp(ByRef KeyCode As VBRUN.KeyCodeConstants, _
                                    ByVal ShiftState As VBRUN.ShiftConstants) _
                Implements VB.IWindowElementEventsCommonControls.KeyUp
                
            Dim KeyCodeInt As Integer = CInt(KeyCode)
            RaiseEvent KeyUp(KeyCodeInt, CInt(ShiftState))
            KeyCode = CType(Of VBRUN.KeyCodeConstants)(KeyCodeInt)
        End Sub
        
        Protected Sub HandleKeyPress(ByRef Key As Integer) _
                Implements VB.IWindowElementEventsCommonControls.KeyPress
                
            RaiseEvent KeyPress(Key)
        End Sub
                
        [Serialize(False)]
        Public Property Get Min() As Long
            Return SendMessageLng(TBM_GETRANGEMIN, 0, 0)
        End Property
        
        [Serialize(False)]
        Public Property Let Min(ByVal Value As Long)
            SendMessageLngPtr(TBM_SETRANGEMIN, 1, Value)
        End Property
        
        [Serialize(False)]
        Public Property Get Max() As Long
            Return SendMessageLng(TBM_GETRANGEMAX, 0, 0)
        End Property
        
        [Serialize(False)]
        Public Property Let Max(ByVal Value As Long)
            SendMessageLngPtr(TBM_SETRANGEMAX, 1, Value)
        End Property
                
        [Serialize(False), DefaultMember]
        Public Property Get Value() As Long
            Return SendMessageLng(TBM_GETPOS, 0, 0)
        End Property
        
        [Serialize(False), DefaultMember]
        Public Property Let Value(ByVal NewValue As Long)
            If Me.Value <> NewValue Then
                SendMessageLngPtr(TBM_SETPOS, 1, NewValue)
                If IsInitialized Then RaiseEvent Change
            End If
        End Property
        
        [Serialize(False)]
        Public Property Get Parent() As Object ' As Form  FIXME, needs to work also for UCs
            Return ControlContext.RuntimeUICtxEnsureGetForm()
        End Property
        
        [Serialize(False)]
        Public Property Get Object() As Object
            Return Me
        End Property

        Protected Sub HandleDragOver(ByVal Source As Object, ByVal X As Double, ByVal Y As Double, ByVal State As Long) _
                Implements VB.IWindowElementEventsAX.DragOver
            
            If State = 3 Then
                RaiseEvent DragDrop(Source, CSng(X), CSng(Y))
            Else
                RaiseEvent DragOver(Source, CSng(X), CSng(Y), CInt(State))
            End If
        End Sub
        
        Protected Sub SyncStyles() _
                Handles HideThumb.OnPropertyLet, _
                        TickStyle.OnPropertyLet, _
                        Orientation.OnPropertyLet, _
                        ShowTip.OnPropertyLet, _
                        SelectRange.OnPropertyLet
            Dim hwnd As Any = RootWindowElementBase.RuntimeUIGetHandle()
            Dim origStyles As Long = CLng(hwnd.GetWindowLongW(VB.GWL_STYLE))
            hwnd.SetWindowLongW(VB.GWL_STYLE, (origStyles And VB.WS_CHILD) Or (origStyles And VB.WS_VISIBLE) Or GetStyles())
        
            If SelectRange And ((origStyles And TBS_ENABLESELRANGE) = 0) Then
                SelStart = InternalRangeStart
                SelLength = 0
            End If
        End Sub
                
        [Serialize(False)]
        Public Property Get SelStart() As Long
            If SelectRange = False Then
                Return InternalRangeStart
            Else
                Return SendMessageLng(TBM_GETSELSTART, 0, 0)
            End If
        End Property
        
        [Serialize(False)]
        Public Property Let SelStart(ByVal Value As Long)
            Dim origSelLength As Long = SelLength
            Dim endPoint As Long = Value + origSelLength

            Select Case Value
                Case Me.Min To Me.Max
                Case Else
                    Err.Raise 380
            End Select
            
            If endPoint > Me.Max Then
                endPoint = Me.Max
            End If
                        
            If SelectRange = True Then
                SendMessageLngPtr(TBM_SETSELSTART, 0, Value)
                SendMessageLngPtr(TBM_SETSELEND, 1, endPoint)
            Else
                InternalRangeStart = Value
            End If
        End Property
        
        [Serialize(False)]
        Public Property Get SelLength() As Long
            If SelectRange = False Then
                Return 0
            Else
                Return SendMessageLng(TBM_GETSELEND, 0, 0) - SelStart
            End If
        End Property
        
        [Serialize(False)]
        Public Property Let SelLength(ByVal Value As Long)
            If SelectRange = False Then
            Else
                Dim endPoint As Long = Me.SelStart + Value
                Select Case endPoint
                    Case Me.Min To Me.Max
                    Case Else
                        Err.Raise 380
                End Select
                SendMessageLngPtr(TBM_SETSELEND, 1, SelStart + Value)
            End If
        End Property
        
        [Serialize(False)]
        Public Property Get SmallChange() As Long
        	Return SendMessageLng(TBM_GETLINESIZE, 0, 0)
        End Property
        
        [Serialize(False)]
        Public Property Let SmallChange(ByVal Value As Long)
            SendMessageLngPtr(TBM_SETLINESIZE, 0, Value)
        End Property
        
        [Serialize(False)]
        Public Property Get LargeChange() As Long
        	Return SendMessageLng(TBM_GETPAGESIZE, 0, 0)
        End Property
        
        [Serialize(False)]
        Public Property Let LargeChange(ByVal Value As Long)
            SendMessageLngPtr(TBM_SETPAGESIZE, 0, Value)
        End Property
        
        Protected Sub SyncTextPosition() _
                Handles TextPosition.OnPropertyLet

            Dim tipSide As Long
            If Me.Orientation = Orientation.ccOrientationHorizontal Then
                tipSide = If(TextPosition = TextPositionConstants.sldAboveLeft, TBTS_TOP, TBTS_BOTTOM)
            Else
                tipSide = If(TextPosition = TextPositionConstants.sldAboveLeft, TBTS_LEFT, TBTS_RIGHT)
            End If
            SendMessageLngPtr(TBM_SETTIPSIDE, tipSide, 0)
        End Sub
        
        Protected Sub SyncTickFrequency() _
        	    Handles TickFrequency.OnPropertyLet
                
            If TickFrequency < 0 Then
                TickFrequency = 0
            End If
            SendMessageLngPtr(TBM_SETTICFREQ, TickFrequency, 0)
        End Sub
        
        #If FEATURE_OLEDRAGDROP Then
        Public Sub OLEDrag()
            VB.CommonOLEDrag(Me)
        End Sub

        Protected Sub SyncOLEDropMode() _
                Handles OLEDropMode.OnPropertyLet
                
            BaseSyncOLEDropMode (Me, Me.OLEDropMode, Me.OLEDragDropHandler, False, True)
        End Sub
        #End If
        
        Protected Sub HandleScroll(ByVal ScrollType As Long, ByVal IsHorizontal As Boolean) _
                Implements VB.IWindowElementEventsCommon.Scroll
            
            'Debug.Print "Scroll", ScrollType
            Select Case ScrollType
                Case TB_THUMBTRACK, TB_THUMBPOSITION, TB_LINEDOWN, TB_LINEUP, TB_PAGEDOWN, TB_PAGEUP
                    RaiseEvent Scroll
            	Case TB_BOTTOM, TB_TOP, TB_ENDTRACK
                	RaiseEvent Change
            End Select
        End Sub
        
        Protected Sub HandleGetColors(ByVal hdc As VB.HDC, BackBrushOut As LongPtr, ByVal ControlType As Long) _
                Implements VB.IWindowElementEventsGraphics.GetColors
            
            BackBrushOut = Me.CreateBackBrush(Me.BackColor)
        End Sub
        
        Protected Sub HandleValidate(Cancel As Boolean) _
                Implements VB.IWindowElementEventsCommon.Validate

            RaiseEvent Validate(Cancel)
        End Sub
        
        [Serialize(False)]
        Public Property Get ToolTipText() As String
            Return InternalBaseControlInfo.ToolTipText
        End Property
    
        [Serialize(False)]
        Public Property Let ToolTipText(ByVal Value As String)
            InternalBaseControlInfo.ToolTipText = Value
            RootWindowElementBase.RuntimeUIToolTipChanged()
        End Property
        
        [Serialize(False)]
        [Description("Determines if the OS should use visual styles for rendering this control")]
        Public Property Get VisualStyles() As Boolean
            Return InternalBaseControlInfo.VisualStyles
        End Property
    
        [Serialize(False)]
        [Description("Determines if the OS should use visual styles for rendering this control")]
        Public Property Let VisualStyles(ByVal Value As Boolean)
            Me.VisualStylesINIT = Value
            RootWindowElementBase.RuntimeUIRemoveVisualStyles(RootWindowElementBase.RuntimeUIGetHandle(), Not Value)
        End Property
    #End Region
End Class

[WindowsControl("/miscellaneous/ICONS??/Slider??.png")]
[ClassId("FE755F8E-4EF9-42A4-A88B-B876EF5B4450")]
[InterfaceId("BD91F6FC-5074-4D76-B43A-502BB9D51656")]
[COMCreatable(False)]
[EventsUseDispInterface]
Class Slider
    Inherits SliderBaseCtl
    
    Protected Sub Class_BeforeFirstMethodAccess()
        [_HiddenModule].EnsureContainerIsLoaded(Me)
    End Sub
End Class
#End If