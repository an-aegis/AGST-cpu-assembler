#If FEATURE_ACTIVEX_CONTROLS Then
Private Module UcInternalStateMod
    Type UcInternalState
        PropertiesChanged As Boolean
        OleClientSite As IOleClientSite
        CachedExtender As Object
        ContainerWindow As LongPtr
        WindowIsInPlace As Boolean
        IsInitialized As Boolean
        IsInitialized1 As Boolean
        IsDesignMode As Boolean
        IsTbDebugging As Boolean
        MutedResizeEventsCount As Long
        InitialResizeEventFired As Boolean
        QueuedShowEvent As Boolean
        ConsumerVisibilityState As Boolean      ' as per Show/Hide events, which might be delayed due to FreezeEvents
        'ActualVisibilityState As Boolean
        IsHandlingPaint As Boolean
        WindowlessRect As tbRECT
        ClippedRect As tbRECT
        IsWindowlessActivated As Boolean
        IsLoaded As Boolean
        IsInResizeEvent As Boolean
        WindowRgnIsClipped As Boolean
        WindowRgnIsPending As Boolean
        HwndIsParented As Boolean
        DoLoadNowProcessed As Boolean
        
        siteFrame As IOleInPlaceFrame
        siteDoc As IOleInPlaceUIWindow
        hasFocus As Boolean
        hasFocusOnChild As Boolean
        IViewObject_adviseSink As VBRUN.tbInternal_IAdviseSink
        IsClosed As Boolean
        _containerHwnd As LongPtr
        _oldParentHwnd As LongPtr
        
        IgnorePropertyChangedNotifications As Long
        HasFinishedLoading As Boolean
        HasRaisedInitialResizeEvent As Boolean
        IsSettingInitialSize As Boolean
        ChangedSizeDuringInitialResizeEvent As Boolean
        IsInResizeCallback As Boolean
        IsCreatingWindow As Boolean
        _ExtentX As Double
        _ExtentY As Double
        
        OriginalParentHWND As LongPtr	        ' ThunderMain
        
        InternalHostDoesUpdateContextRect As Boolean
        InternalDoesntNeedToCheckHost As Boolean
        InternalIgnoreHostDesignerChanges As Boolean
        InternalCachedHeightRequest As Double
        InternalCachedHeightResult As Double
        InternalCachedWidthRequest As Double
        InternalCachedWidthResult As Double
    End Type
    
    Public Sub ResetUcInternalState(InternalState As UcInternalState)
        Set InternalState.OleClientSite = Nothing
        Set InternalState.CachedExtender = Nothing
        Set InternalState.siteFrame = Nothing
        Set InternalState.siteDoc = Nothing
        Set InternalState.IViewObject_adviseSink = Nothing
        [_HiddenModule].MemZero(VarPtr(InternalState), LenB(InternalState))
    End Sub
End Module

[ComImport(True)]
[InterfaceId("974AF59D-5EA0-4D26-8CD0-5624E0A71134")]
Private Interface TbUserControlPrivate Extends stdole.IUnknown
    Property Get WindowlessRectLeft() As Long
    Property Get WindowlessRectTop() As Long
    Property Get WindowlessRectRight() As Long
    Property Get WindowlessRectBottom() As Long
    Function TranslateContainerXToHimetric(ByVal containerValue As Single) As Long
    Function TranslateContainerYToHimetric(ByVal containerValue As Single) As Long
    Function TranslateHimetricToContainerX(ByVal himetricValue As Long) As Single
    Function TranslateHimetricToContainerY(ByVal himetricValue As Long) As Single
End Interface

' [COMCreatable(False)]
' [InterfaceId("6A55A6D1-C840-4E80-8961-0AAC322A3AFF")]
' Protected Class UCParentControls
'     Implements ParentControls
    
'     Protected UCWeak As LongPtr
'     Protected InternalParentControlsType As ParentControlsType = ParentControlsType.vbExtender
'     Protected InternalSnapshot As Collection
    
'     ' For now we take a snapshot of the parent controls, to make things easier
'     ' FIXME rewrite this to work 'live'
'     ' FIXME this is probably creating circular references due to the caching/snapshotting
        
'     Sub New(UC As UserControl)
'         Me.UCWeak = ObjPtr(UC)
'     End Sub
    
'     Protected Function GetUC() As UserControl
'         PutMemPtr(VarPtr(GetUC), UCWeak)
'         [_HiddenModule].vbaObjAddref(UCWeak)
'     End Function
    
'     Sub RefreshSnapshot()
'         Set InternalSnapshot = New Collection
      
'         On Error GoTo ErrorHandler
'         Dim o As IOleObject = GetUC()
'         Dim s As IOleClientSite
'         o.GetClientSite(s)
'         Dim c As IOleContainer
'         s.GetContainer(c)
'         Dim enum As IEnumUnknown
'         c.EnumObjects(OLECONTF_EMBEDDINGS Or OLECONTF_LINKS Or OLECONTF_ONLYIFRUNNING Or OLECONTF_ONLYUSER Or OLECONTF_OTHERS, enum)
        
'         Const S_FALSE As Long = 1
'         Dim fetched As Long
'         Dim ctlUnk As IUnknown
'         Dim ctl As Object
'         Dim ctlObj As IOleObject
        
'         While 1
'             On Error Resume Next
'             Err.Clear()
'             enum.Next(1, ctlUnk, fetched)
'             If (Err.LastHresult = S_FALSE) Or (Err.Number <> 0) Or (fetched <> 1) Then Exit While
            
'             Set ctl = Nothing
            
'             If InternalParentControlsType = vbExtender Then
'                 Set ctlObj = Nothing
'                 Set ctlObj = CType(Of IOleObject)(ctlUnk)
'                 If ctlObj Is Nothing Then GoTo DoNoneAxControl
'                 Dim ctlSite As IOleClientSite = Nothing
'                 ctlObj.GetClientSite(ctlSite)
'                 Dim ctlSite2 As IOleControlSite = CType(Of IOleControlSite)(ctlSite)
'                 ctlSite2.GetExtendedControl(ctl)
'             Else
'             DoNoneAxControl:
'                 Set ctl = ctlUnk
'             End If
            
'             If ctl IsNot Nothing Then
'                 InternalSnapshot.Add(ctl)
'             End If
'         Wend
'         Exit Sub
'     ErrorHandler:
'     End Sub
        
'     Protected Property Get ParentControls_Count() As Long
'         If InternalSnapshot Is Nothing Then RefreshSnapshot()
'         Return InternalSnapshot.Count
'     End Property
    
'     Property Get ParentControls_Item(ByVal index As Long) As Object
'         If InternalSnapshot Is Nothing Then RefreshSnapshot()
'         If (index < 0) Or (index >= InternalSnapshot.Count) Then
'             Err.Raise 381, , "Invalid property array index"
'         End If
'         Return InternalSnapshot.Item(index - 1)
'     End Property
    
'     [Enumerator]
'     Function ParentControls__NewEnum() As IUnknown Implements ParentControls.[_NewEnum]
'         If InternalSnapshot Is Nothing Then RefreshSnapshot()
'         Return CallByDispId(InternalSnapshot, -4, vbGet)
'     End Function
    
'     Property Get ParentControls_ParentControlsType() As ParentControlsType
'         Return Me.InternalParentControlsType
'     End Property
    
'     Property Let ParentControls_ParentControlsType(ByVal Value As ParentControlsType)
'         Me.InternalParentControlsType = Value
'         Set InternalSnapshot = Nothing
'     End Property

' End Class


[COMCreatable(False)]
[InterfaceId("1E672A77-97F3-4346-859B-4E9CFD10F625")]
Private Class UCRawControls2Enum
    Implements IEnumVARIANT_TB
    
    Protected Owner As UCParentControls2
    Protected RawEnum As IEnumUnknown
    
    Sub New(Owner As UCParentControls2, RawEnum As IEnumUnknown)
        Set Me.Owner = Owner
        Set Me.RawEnum = RawEnum
    End Sub
    
    Protected Sub Next(ByVal celt As Long, rgvar As Variant, pceltFetched As Long) _
            Implements IEnumVARIANT_TB.Next
        
        If (celt = 0) Or (VarPtr(rgvar) = 0) Then
            Const E_UNEXPECTED As Long = &H8000FFFF
            Err.ReturnHResult = E_UNEXPECTED
            Exit Sub
        End If
        
        Dim arrayOfControls() As stdole.IUnknown
        ReDim arrayOfControls(0 To (celt - 1))
       
        On Error Resume Next
        Err.Clear()
        
        If VarPtr(pceltFetched) <> vbNullPtr Then pceltFetched = 0
        Dim fetched As Long = 0
        RawEnum.Next(celt, arrayOfControls(0), fetched)
        If VarPtr(pceltFetched) <> vbNullPtr Then pceltFetched = fetched
        
        Dim ctlIdx As Long
        While ctlIdx < fetched
            Dim ctlUnk As stdole.IUnknown = arrayOfControls(ctlIdx)
            Dim ctl As Object
            Dim ctlObj As IOleObject
            
            If (Me.Owner Is Nothing) OrElse (CType(Of ParentControls)(Me.Owner).ParentControlsType = vbExtender) Then
               Set ctlObj = Nothing
               Set ctlObj = CType(Of IOleObject)(ctlUnk)
               If ctlObj Is Nothing Then GoTo DoNoneAxControl
               Dim ctlSite As IOleClientSite = Nothing
               ctlObj.GetClientSite(ctlSite)
               Dim ctlSite2 As IOleControlSite = CType(Of IOleControlSite)(ctlSite)
               If ctlSite2 Is Nothing Then GoTo DoNoneAxControl
               ctlSite2.GetExtendedControl(ctl)
            Else
            DoNoneAxControl:
                Set ctl = ctlUnk
            End If
            
            Dim ctlVar As Variant
            Set ctlVar = ctl
            vbaCopyBytesZero(LenB(Of Variant), VarPtr(rgvar) + (ctlIdx * LenB(Of Variant)), VarPtr(ctlVar))
            ctlIdx += 1
        Wend
        
        If fetched = 0 Then Err.ReturnHResult = 1  ' S_FALSE
    End Sub
    
    Protected Sub Clone(ppenum As stdole.IEnumVARIANT) _
            Implements IEnumVARIANT_TB.Clone
        Set ppenum = New UCRawControls2Enum(Me.Owner, Me.RawEnum)
    End Sub
    
    Protected Sub Reset() _
            Implements IEnumVARIANT_TB.Reset
        Me.RawEnum.Reset()
    End Sub
    
    Protected Sub Skip(ByVal celt As Long) _
            Implements IEnumVARIANT_TB.Skip
        Me.RawEnum.Skip(celt)
    End Sub
    
End Class


[COMCreatable(False)]
[InterfaceId("6A55A6D1-C840-4E80-8961-0AAC322A3AFF")]
Private Class UCParentControls2

    ' This has to provide live data
    
    Implements ParentControls
    
    Protected UCWeak As LongPtr
    Protected InternalParentControlsType As ParentControlsType = ParentControlsType.vbExtender
    
    ' FIXME this is probably creating circular references due to the caching/snapshotting
        
    Protected InternalEnum As IEnumUnknown
    
    Sub New(UC As UserControlBaseCtl)
        Me.UCWeak = ObjPtr(UC)
        
        On Error GoTo ErrorHandler
        Dim o As IOleObject = UC
        Dim s As IOleClientSite
        o.GetClientSite(s)
        Dim c As IOleContainer
        s.GetContainer(c)
        c.EnumObjects(OLECONTF_EMBEDDINGS Or OLECONTF_LINKS Or OLECONTF_ONLYIFRUNNING Or OLECONTF_ONLYUSER Or OLECONTF_OTHERS, InternalEnum)
        
        ErrorHandler:
        'MsgBox "ParentControls enum: " & Hex(ObjPtr(InternalEnum))
    End Sub
    
    Protected Function GetUC() As UserControlBaseCtl
        PutMemPtr(VarPtr(GetUC), UCWeak)
        [_HiddenModule].vbaObjAddref(UCWeak)
    End Function
    
    Protected Property Get GetCount() As Long _
            Implements ParentControls.Count
        If InternalEnum Is Nothing Then
            Return 0
        End If
        InternalEnum.Reset()
        Dim count As Long = 0
        While 1
            On Error Resume Next
            Err.Clear()
            Dim ctlUnk As IUnknown
            Dim fetched As Long = 0
            InternalEnum.Next(1, ctlUnk, fetched)
            Set ctlUnk = Nothing
            Const S_FALSE As Long = 1
            If (Err.LastHresult = S_FALSE) Or (Err.Number <> 0) Or (fetched <> 1) Then Exit While
            count += 1
        Wend
        Return count
    End Property
    
    Property Get GetItem(ByVal index As Long) As Object _
            Implements ParentControls.Item
        If (index < 0) Or (InternalEnum Is Nothing) Then
            Err.Raise 381, , "Invalid property array index"
        End If
        
        InternalEnum.Reset()
        Dim currentIdx As Long = 0
        While currentIdx <= index
            On Error Resume Next
            Err.Clear()
            Dim ctlUnk As IUnknown
            Dim fetched As Long = 0

            InternalEnum.Next(1, ctlUnk, fetched)
            Const S_FALSE As Long = 1
            If (Err.LastHresult = S_FALSE) Or (Err.Number <> 0) Or (fetched <> 1) Then Exit While
            
            If currentIdx = index Then
            
                If InternalParentControlsType = vbExtender Then
                    Dim ctlObj As IOleObject = CType(Of IOleObject)(ctlUnk)
                    If ctlObj Is Nothing Then GoTo DoNoneAxControl
                    Dim ctlSite As IOleClientSite = Nothing
                    ctlObj.GetClientSite(ctlSite)
                    Dim ctlSite2 As IOleControlSite = CType(Of IOleControlSite)(ctlSite)
                    Dim ctl As Object
                    ctlSite2.GetExtendedControl(ctl)
                    Return ctl
                Else
                DoNoneAxControl:
                    Return ctlUnk
                End If
                
            End If
            Set ctlUnk = Nothing
            currentIdx += 1
        Wend
        
        On Error GoTo 0
        Err.Raise 381, , "Invalid property array index"
    End Property
    
    [Enumerator]
    Function _NewEnum() As IUnknown _
            Implements ParentControls._NewEnum
        Dim newEnum As IEnumUnknown
        If InternalEnum IsNot Nothing Then InternalEnum.Clone(newEnum)
        Return New UCRawControls2Enum(Me, newEnum)
    End Function
    
    Property Get GetParentControlsType() As ParentControlsType _
            Implements ParentControls.ParentControlsType
        Return Me.InternalParentControlsType
    End Property
    
    Property Let LetParentControlsType(ByVal Value As ParentControlsType) _
            Implements ParentControls.ParentControlsType
        Me.InternalParentControlsType = Value
    End Property

End Class

[COMCreatable(False)]
[InterfaceId("A9E082EB-4BC6-43C8-806D-97D70CE4D5E9")]
Private Class UCContainedControls

    ' This has to provide live data
    
    Implements ContainedControls
    
    Protected UCWeak As LongPtr
    
    ' FIXME this is probably creating circular references due to the caching/snapshotting
        
    Protected InternalEnum As IEnumUnknown
    
    Sub New(UC As UserControlBaseCtl)
        Me.UCWeak = ObjPtr(UC)
        
        'Stop
        On Error GoTo ErrorHandler
        Dim o As IOleObject = UC
        Dim s As IOleClientSite
        o.GetClientSite(s)
        ' Dim c As IOleContainer
        ' s.GetContainer(c)
        ' c.EnumObjects(OLECONTF_EMBEDDINGS Or OLECONTF_LINKS Or OLECONTF_ONLYIFRUNNING Or OLECONTF_ONLYUSER Or OLECONTF_OTHERS, InternalEnum)
        Dim c As IVBGetControl
        Set c = CType(Of IVBGetControl)(s)
        c.EnumControls(31, 3, InternalEnum)
        
        ErrorHandler:
    End Sub
    
    Protected Function GetUC() As UserControlBaseCtl
        PutMemPtr(VarPtr(GetUC), UCWeak)
        [_HiddenModule].vbaObjAddref(UCWeak)
    End Function
    
    Protected Property Get GetCount() As Long _
            Implements ContainedControls.Count
        InternalEnum.Reset()
        Dim count As Long = 0
        While 1
            On Error Resume Next
            Err.Clear()
            Dim ctlUnk As IUnknown
            Dim fetched As Long = 0
            InternalEnum.Next(1, ctlUnk, fetched)
            Set ctlUnk = Nothing
            Const S_FALSE As Long = 1
            If (Err.LastHresult = S_FALSE) Or (Err.Number <> 0) Or (fetched <> 1) Then Exit While
            count += 1
        Wend
        Return count
    End Property
    
    Property Get GetItem(ByVal index As Long) As Object _
            Implements ContainedControls.Item
        If (index < 0) Then
            Err.Raise 381, , "Invalid property array index"
        End If
        
        InternalEnum.Reset()
        Dim currentIdx As Long = 0
        While currentIdx <= index
            On Error Resume Next
            Err.Clear()
            Dim ctlUnk As IUnknown
            Dim fetched As Long = 0

            InternalEnum.Next(1, ctlUnk, fetched)
            Const S_FALSE As Long = 1
            If (Err.LastHresult = S_FALSE) Or (Err.Number <> 0) Or (fetched <> 1) Then Exit While
            
            If currentIdx = index Then
            
                ' If InternalParentControlsType = vbExtender Then
                '     Dim ctlObj As IOleObject = CType(Of IOleObject)(ctlUnk)
                '     If ctlObj Is Nothing Then GoTo DoNoneAxControl
                '     Dim ctlSite As IOleClientSite = Nothing
                '     ctlObj.GetClientSite(ctlSite)
                '     Dim ctlSite2 As IOleControlSite = CType(Of IOleControlSite)(ctlSite)
                '     Dim ctl As Object
                '     ctlSite2.GetExtendedControl(ctl)
                '     Return ctl
                ' Else
                ' DoNoneAxControl:
                    Return ctlUnk
                'End If
                
            End If
            Set ctlUnk = Nothing
            currentIdx += 1
        Wend
        
        On Error GoTo 0
        Err.Raise 381, , "Invalid property array index"
    End Property
    
    [Enumerator]
    Function _NewEnum() As IUnknown _
            Implements ContainedControls._NewEnum
        Dim newEnum As IEnumUnknown
        InternalEnum.Clone(newEnum)
        Return New UCRawControls2Enum(Nothing, newEnum)
    End Function
    
End Class

' FIXME this is just an empty implementation for now
[InterfaceId("DB4149A3-52DC-4EB2-B584-79FD7A0CDA46")]
' Class EmptyContainedControls
' 	Implements ContainedControls
    
'     [Unimplemented]
'     Property Get ContainedControls_Count() As Long
'     	Return 0
'     End Property

'     [Unimplemented]
'     Property Get ContainedControls_Item(ByVal index As Long) As Object
'     	Err.Raise 5
'     End Property

'     [Unimplemented]
'     [Enumerator]
'     Function _NewEnum() As IUnknown Implements ContainedControls.[_NewEnum]
'     	Return CallByDispId(New Collection, -4, vbGet)
'     End Function

' End Class

' Host does NOT have to support AmbientProperties interface IID, so we have to use a passthru wrapper
[COMCreatable(False)]
[InterfaceId("0CCFCC46-8780-43A7-8AAD-70660FBFDAD7")]
Private Class AmbientPropertiesPassThru
	
    Implements AmbientProperties
    
    Protected HostAmbient As Object
    
    Sub New(Host As Object)
        'MsgBox "AmbientPropertiesPassThru"
    	Set HostAmbient = Host
    End Sub
    
    Protected Function GetAmbientProp(ByVal dispatchID As Long, ByRef defaultValue As Variant) As Variant
        On Error Resume Next
        Dim retVal As Variant = CallByDispId(HostAmbient, dispatchID, VbCallType.vbMethod Or VbCallType.vbGet)
        If (Err.Number <> 0) OrElse (VarType(retVal) = vbEmpty) Then
            retVal = defaultValue
        End If
        Return retVal
    End Function
    
    Protected Property Get BackColor() As stdole.OLE_COLOR _
            Implements AmbientProperties.BackColor
    	Return CLng(GetAmbientProp(-701, &H80000005))     ' Same as VBx
    End Property
    
    Protected Property Get DisplayName() As String _
            Implements AmbientProperties.DisplayName
        Return CStr(GetAmbientProp(-702, ""))     ' Same as VBx
    End Property
    
    Protected Property Get Font() As stdole.IFontDisp _
            Implements AmbientProperties.Font
        Dim retVal As Variant = GetAmbientProp(-703, Nothing)     ' Same as VBx
        If retVal Is Nothing Then Set retVal = New StdFont
        Return CType(Of IFontDisp)(retVal)
    End Property

    Protected Property Get ForeColor() As stdole.OLE_COLOR _
            Implements AmbientProperties.ForeColor
        Return CLng(GetAmbientProp(-704, &H80000008))     ' Same as VBx
    End Property

    Protected Property Get LocaleID() As Long _
            Implements AmbientProperties.LocaleID
        Return CLng(GetAmbientProp(-705, &H809))     ' Same as VBx
    End Property

    Protected Property Get MessageReflect() As Boolean _
            Implements AmbientProperties.MessageReflect
        Return GetAmbientProp(-706, False)     ' Same as VBx
    End Property

    Protected Property Get ScaleUnits() As String _
            Implements AmbientProperties.ScaleUnits
        Return CStr(GetAmbientProp(-707, ""))     ' Same as VBx
    End Property

    Protected Property Get TextAlign() As Integer _
            Implements AmbientProperties.TextAlign
        Return CInt(GetAmbientProp(-708, 0))     ' Same as VBx
    End Property

    Protected Property Get UserMode() As Boolean _
            Implements AmbientProperties.UserMode
        Return GetAmbientProp(-709, True)     ' Same as VBx
    End Property

    Protected Property Get UIDead() As Boolean _
            Implements AmbientProperties.UIDead
        Return GetAmbientProp(-710, False)     ' Same as VBx
    End Property
    
    Protected Property Get ShowGrabHandles() As Boolean _
            Implements AmbientProperties.ShowGrabHandles
        Return GetAmbientProp(-711, True)     ' Same as VBx
    End Property
    
    Protected Property Get ShowHatching() As Boolean _
            Implements AmbientProperties.ShowHatching
        Return GetAmbientProp(-712, True)     ' Same as VBx
    End Property

    Protected Property Get DisplayAsDefault() As Boolean _
            Implements AmbientProperties.DisplayAsDefault
        Return GetAmbientProp(-713, False)     ' Same as VBx
    End Property

    Protected Property Get SupportsMnemonics() As Boolean _
            Implements AmbientProperties.SupportsMnemonics
        Return GetAmbientProp(-714, False)     ' Same as VBx
    End Property

    Protected Property Get Palette() As stdole.IPictureDisp _
            Implements AmbientProperties.Palette
        Dim retVal As Variant = GetAmbientProp(-726, Nothing)     ' Same as VBx
        If retVal Is Nothing Then
            ' If the host doesn't support Palette, VBx UserControl throws an error here...
            Err.Raise 5, , "ActiveX control does not support Palette ambient property"
        End If
        If retVal = 0 Then
            Return Nothing
        Else
            ' FIXME convert HPALETTE to StdPicture?
            Return Nothing
        End If
        Return CType(Of IPictureDisp)(retVal)
    End Property

    Protected Property Get RightToLeft() As Boolean _
            Implements AmbientProperties.RightToLeft
        Return GetAmbientProp(-732, False)     ' Same as VBx
    End Property
End Class

[COMCreatable(False)]
Private Class UcVerbEnumerator
    Implements IEnumOLEVERB
    
    Private CurrentIndex As Long
    Private UC As UserControlBaseCtl
    
    Sub New(UC As UserControlBaseCtl)
        Set Me.UC = UC
    End Sub
    
    Const CUSTOM_OLEIVERB_1 As Long = 1
    
    Private Sub IEnumOLEVERBNext(ByVal celt As Long, rgelt As OLEVERB, pceltFetched As Long) _
            Implements IEnumOLEVERB.Next
        ' FIXME check what VB6 actually outputs here
        If VarPtr(pceltFetched) <> vbNullPtr Then pceltFetched = 0
        Dim outCount As Long
        Dim customVerbs As Any = UC.Verbs
        Dim rgeltPtr As LongPtr = VarPtr(rgelt)
        'MsgBox "IEnumOLEVERBNext:celt = " & celt
        
        Dim ActualIndex As Long = CurrentIndex
        If UBound(UC.PropertyPages) > -1 Then
            ' If the UC exposes PropertyPages, add a 'Properties' entry to the verbs
            If CurrentIndex = 0 Then
                With CType(Of OLEVERB)(rgeltPtr)
                    .lpszVerbName = OLE32.OleAllocString("Properties")
                    .lVerb = CUSTOM_OLEIVERB_1
                    .grfAttribs = 2
                    rgeltPtr += LenB(Of OLEVERB)
                End With
                
                CurrentIndex += 1
                outCount += 1
                If VarPtr(pceltFetched) Then pceltFetched = outCount
            Else
                ActualIndex = CurrentIndex - 1
            End If
        End If
        
        While outCount < celt
            If ActualIndex > UBound(customVerbs) Then
                'MsgBox "Returning S_FALSE"
                Err.ReturnHResult = S_FALSE
                rgelt.lpszVerbName = vbNullPtr
                Exit While
            End If
            'MsgBox "Returning verb: " & RawArray(ActualIndex).Name
            With CType(Of OLEVERB)(rgeltPtr)
                .lpszVerbName = OLE32.OleAllocString(customVerbs(ActualIndex))
                .lVerb = 2 + ActualIndex
                .grfAttribs = 2
                rgeltPtr += LenB(Of OLEVERB)
            End With
            CurrentIndex += 1
            ActualIndex += 1
            outCount += 1
            If VarPtr(pceltFetched) Then pceltFetched = outCount
        Wend
    End Sub
    
    Private Sub IEnumOLEVERBClone(ppenum As IEnumOLEVERB) _
            Implements IEnumOLEVERB.Clone
        Err.ReturnHResult = E_NOTIMPL
    End Sub
    
    Private Sub IEnumOLEVERBReset() _
            Implements IEnumOLEVERB.Reset
        CurrentIndex = 0
    End Sub
    
    Private Sub IEnumOLEVERBSkip(ByVal celt As Long) _
            Implements IEnumOLEVERB.Skip
        CurrentIndex += celt
        If CurrentIndex > UBound(UC.Verbs) Then
            Err.ReturnHResult = S_FALSE
            CurrentIndex -= celt
        End If
    End Sub
End Class

[ClassId("2F974DBE-DE1D-474F-A7D7-AA52CAD31568")]
[InterfaceId("D43E6EDB-D8C1-4FFE-85D0-459FBA563BBA")]    ' FIXME implement {33AD5011-6699-11CF-B70C-00AA0060D393} for backcompat
' WARNING: above InterfaceId is referred to as IID_ITBUserControl in tB Sources
[COMCreatable(False)]
'[COMExtensible(True)]
[EventsUseDispInterface]
[ComImport(True)]
Private Class UserControlBaseCtl
          
    Enum VbClipBehavior
        vbClipNone = 0
        vbClipUseRegion = 1
    End Enum
    
    Enum VbDataBindingBehavior
        vbDataBindingNone = 0
        vbDataBindingSimple = 1
        vbDataBindingComplex = 2
    End Enum
    
    Enum VbDataSourceBehavior
        vbDataSourceNone = 0
        vbDataSource = 1
    End Enum
    
    Enum VbHitTestBehavior
        vbHitTestNone = 0
        vbHitTestUseRegion = 1
        vbHitTestPaint = 2
    End Enum
        
     #Region "INHERITANCE"

        Inherits BaseUserControl
        Inherits GraphicsBase
        #If FEATURE_OLEDRAGDROP Then
        Inherits OLEDragDropHelper
        #End If
        
        Implements IWindowsControl
        [WithDispatchForwarding] Implements Control
        Implements ITbCommonContainerPrivate
        Implements TbUserControlPrivate
        Implements IOleObject
        Implements IPersistStreamInit
        Implements IPersist
        Implements IOleControl
        Implements IPersistStorage
        Implements IPersistPropertyBag
        Implements IProvideClassInfo
        Implements IViewObject
        Implements IOleInPlaceObject
        Implements ISpecifyPropertyPages
        Implements IPerPropertyBrowsing
        Implements IOleInPlaceActiveObject
        'Implements IQuickActivate              ' FIXME put this back on
        Implements IOleInPlaceObjectWindowless     ' FIXME only when Windowless = True
        Implements IViewObjectEx                   ' FIXME only when Windowless = True (for hittesting of transparent controls)
        Implements IScheduledCallback
        Implements ITwinBasicDesignerExtensions2
        Implements IOleContainer
        Implements ISupportsNotifySink
        Implements IWindowElementEventsCommon
        Implements IWindowElementEventsCommonRoot
        Implements IWindowElementEventsUC
        Implements IUnsupportedInterface
            
    #End Region
        
    #Region "STATE"
    
            [Serialize(True, ":ForceResizeToContainer")]
            Public ReadOnly ForceResizeToContainer As Boolean = False
            [Serialize(True, ":ControlContainer")]
            Public ReadOnly ControlContainer As Boolean = False
                                    
            Protected Const HWND_BOTTOM                       As Long = 1
            Protected Const PW_CLIENTONLY                     As Long = &H00000001
            Protected Const PW_RENDERFULLCONTENT              As Long = &H00000002
            Protected Const MK_LBUTTON                        As Long = 1
            Protected Const MK_RBUTTON                        As Long = 2
            Protected Const MK_MBUTTON                        As Long = 16
            Protected Const XFORMCOORDS_POSITION              As Long	= &H1
            Protected Const XFORMCOORDS_SIZE                  As Long	= &H2
            Protected Const XFORMCOORDS_HIMETRICTOCONTAINER   As Long	= &H4
            Protected Const XFORMCOORDS_CONTAINERTOHIMETRIC   As Long	= &H8
            Protected Const DVASPECT_CONTENT                  As Long = 1
                        
        [Unimplemented]
            Public AccessKeys As String
        [Unimplemented]
            Public Alignable As Boolean
        '[ Unimplemented ]
            Public BorderStyle As VBRUN.ControlBorderStyleConstants '= ControlBorderStyleConstants.vbNoBorder


        Public BackStyle As BackFillStyleConstants = BackFillStyleConstants.vbBFOpaque

        [Serialize(True, "CanGetFocus")]
        Protected CanGetFocusINIT As Boolean = True
        
        Public ClipBehavior As VbClipBehavior = VbClipBehavior.vbClipUseRegion

        [Unimplemented]
            Public DataBindingBehavior As VbDataBindingBehavior '= VbDataBindingBehavior.vbDataBindingNone
        [Unimplemented]
            Public DataSourceBehavior As VbDataSourceBehavior '= VbDataSourceBehavior.vbDataSourceNone
        
        Public DefaultCancel As Boolean
        
        [Serialize(True, ":PreKeyEvents")]
        [Description("Determines whether PreviewKeyDown/Up messages are active.  Not available on windowless controls")]
        Public ReadOnly PreKeyEvents As Boolean
        
        [Unimplemented]
            Public EditAtDesignTime As Boolean
        [Unimplemented]
            Public ForwardFocus As Boolean
        [Unimplemented]
            Public HitBehavior As VbHitTestBehavior = VbHitTestBehavior.vbHitTestUseRegion

        [Serialize(True, "InvisibleAtRuntime")]
            Public InvisibleAtRuntime As Boolean
        [Unimplemented]
            Public PaletteMode As VBRUN.PaletteModeConstants = VBRUN.PaletteModeConstants.vbPaletteModeContainer
        [Unimplemented]
            Public Public As Boolean = True
        [Unimplemented]
            Public RightToLeft As Boolean
            
       ' FIXME this should only be serialized at DESIGN TIME
       [Serialize(True, "ToolboxBitmap")]
       [CustomDesigner("designer_PictureBytes")]
           Protected ReadOnly ToolboxBitmapINIT() As Byte
            
        Public Windowless As Boolean
            
        [CustomDesigner("designer_SpectrumWindows")]
        [Unimplemented]
            Public MaskColor As OLE_COLOR = SystemColorConstants.vb3DFace

        [Unimplemented]
        [Serialize(True, "MaskPicture")]
        [CustomDesigner("designer_PictureBytes")]
            Protected ReadOnly MaskPictureINIT() As Byte
        [Unimplemented]
        [Serialize(False)]
            Public MaskPicture As StdPicture

        [Serialize(True, "Picture")]
        [CustomDesigner("designer_PictureBytes")]
            Protected ReadOnly PictureINIT() As Byte
            
        [Unimplemented]
        [Serialize(True, "Palette")]
        [CustomDesigner("designer_PictureBytes")]
            Protected ReadOnly PaletteINIT() As Byte
        [Unimplemented]
        [Serialize(False)]
            Public Palette As StdPicture
            
            Protected Const WM_TB_INTERNAL_SELF_DEFERRED_MESSAGE As Long = (WM_USER + &H300 + 14)  ' FIXME also referred to in the C++ side
            Protected Const SELF_DEFFERED_SHOW As Long = 1
            Protected Const SELF_DEFFERED_CLIP As Long = 2
                    
        Protected InternalParentControls As UCParentControls2
        Protected MutedSetExtentResize As Boolean
        
        Private RawArray() As VerbInfo
        Type VerbInfo
            Id As Long
            Name As String
        End Type
        
    
        [Serialize(False)]
            Property Get Ambient() As AmbientProperties
                Dim siteDispatch As stdole.IDispatch = CType(Of IDispatch)(Me.InternalState.OleClientSite)
                Return New AmbientPropertiesPassThru(siteDispatch)
            End Property

        [Unimplemented]
        [Serialize(False)]
            Public Sub AsyncRead(ByVal Target As String, ByVal AsyncType As Long, ByVal PropertyName As Variant, ByVal AsyncReadOptions As Variant)
            End Sub

        [Unimplemented]
        [Serialize(False)]
            Public Sub CancelAsyncRead(ByVal Property As Variant)
            End Sub
            
        [Unimplemented]
        [Serialize(False)]
            Public Function CanPropertyChange(ByVal PropertyName As String) As Boolean
            End Function
            
        [Serialize(False)]
            Public Property Get ContainedControls() As ContainedControls
                Return New UCContainedControls(Me)
                'Return New EmptyContainedControls
            End Property
            
        [Serialize(False)]
            Public Property Get ContainerHwnd() As LongPtr
                On Error Resume Next
                Dim site As Any = CType(Of IOleInPlaceSite)(InternalState.OleClientSite)
                Dim retVal As HWND
                site.GetWindow(retVal)      ' can fail in Access/VBA if called before activated via DoVerb?
                Return retVal.Value
            End Property
            
        [Unimplemented]
        [Serialize(False)]
            Public Sub DataMemberChanged(ByVal DataMember As String)
            End Sub
            
        [Unimplemented]
        [Serialize(False)]
            Public Property Get DataMembers() As DataMembers
            End Property
            
        [Serialize(False)]
            Public Property Get EventsFrozen() As Boolean
                Return InternalBaseControlInfo.EventsAreFrozen
            End Property
            
        [Unimplemented]
        [Serialize(False)]
            Public Property Get Hyperlink() As Hyperlink
            End Property
            
        [Serialize(False)]
            Public Property Get ParentControls() As ParentControls
                If InternalParentControls Is Nothing Then
                    Set InternalParentControls = New UCParentControls2(Me)
                End If
                Return InternalParentControls
            End Property
            
        [Unimplemented]
            Public Sub PopUpMenu(ByVal Menu As Object, Optional ByVal Flags As Variant, Optional ByVal X As Variant, Optional ByVal Y As Variant, Optional ByVal DefaultMenu As Variant)
            End Sub
            
        Public Sub Size(ByVal Width As Single, ByVal Height As Single)
            Dim size As SIZEL
            size.cx = CLng(ScaleX(Width, vbTwips, vbHimetric))
            size.cy = CLng(ScaleY(Height, vbTwips, vbHimetric))
            IOleObjectSetExtent(1, size)
            
            If Me.Ambient.UserMode = False Then
                If InternalState.IsSettingInitialSize = True Then
                    InternalState.ChangedSizeDuringInitialResizeEvent = True
                Else
                    ' update the designer
                    'MsgBox "UC.Size(" & Width & ")"
                    SetExtenderWidthWithCorrection(Width)
                    SetExtenderHeightWithCorrection(Height)
                End If
            End If
        End Sub

        [Unimplemented]
            Public Sub ValidateControls()
            End Sub
            
        #If FEATURE_OLEDRAGDROP Then
        Public Sub OLEDrag()
            CommonOLEDrag(Me)
        End Sub
        #End If
                        
    #End Region

    #Region "EVENTS"
    
        [DefaultDesignerEvent]
        [Description("")]
            Event Initialize()
        [Description("")]
        [DispId(&HEAEA0004)]
        [DispId(&HEAEA0004)]
            Event Click()
        [Description("")]
        [DispId(&HEAEA0005)]
            Event DblClick()
        [Description("")]
        [DispId(&HEAEA0006)]
            Event GotFocus()
        [Description("")]
        [DispId(&HEAEA0008)]
            Event KeyDown(KeyCode As Integer, Shift As Integer)
        [Description("")]
        [DispId(&HEAEA0009)]
            Event KeyPress(KeyAscii As Integer)
        [Description("")]
        [DispId(&HEAEA000A)]
            Event KeyUp(KeyCode As Integer, Shift As Integer)
        [Description("")]
        [DispId(&HEAEA0007)]
            Event LostFocus()
        [Description("")]
        [DispId(&HEAEA0001)]
            Event MouseDown(Button As Integer, Shift As Integer, X As Single, Y As Single)
        [Description("")]
        [DispId(&HEAEA0002)]
            Event MouseMove(Button As Integer, Shift As Integer, X As Single, Y As Single)
        [Description("")]
        [DispId(&HEAEA0003)]
            Event MouseUp(Button As Integer, Shift As Integer, X As Single, Y As Single)
            
        [Description("Fires for all child/descendant controls, and the root UC control.  PreKeyEvents property must be True for this event to fire.  Not available on windowless controls.  Can also use PreKeyWParam/PreKeyLParam properties inside these events.")]
            Event PreKeyDown(KeyCode As Integer, Shift As Integer)
        [Description("Fires for all child/descendant controls, and the root UC control.  PreKeyEvents property must be True for this event to fire.  Not available on windowless controls.  Can also use PreKeyWParam/PreKeyLParam properties inside these events.")]
            Event PreKeyUp(KeyCode As Integer, Shift As Integer)
            

        [Description("")]
            Event Paint()
        [Description("")]
            Event Resize()
            
        [Description("")]
            Event Terminate()
            
        [Description("")]
        [Unimplemented]
        [DispId(&HEAEA000B)]
            Event DragDrop(Source As Control, X As Single, Y As Single)
        [Description("")]
        [Unimplemented]
        [DispId(&HEAEA000C)]
            Event DragOver(Source As Control, X As Single, Y As Single, State As Integer)
            
        Event OLECompleteDrag(Effect As Long)
        Event OLEDragDrop(Data As DataObject, Effect As Long, Button As Integer, Shift As Integer, X As Single, Y As Single)
        Event OLEDragOver(Data As DataObject, Effect As Long, Button As Integer, Shift As Integer, X As Single, Y As Single, State As Integer)
        Event OLEGiveFeedback(Effect As Long, DefaultCursors As Boolean)
        Event OLESetData(Data As DataObject, DataFormat As Integer)
        Event OLEStartDrag(Data As DataObject, AllowedEffects As Long)

        [Description("")]
            Event InitProperties()
        [Description("")]
            Event ReadProperties(ByRef PropBag As PropertyBag)
        [Description("")]
            Event WriteProperties(ByRef PropBag As PropertyBag)
        [Description("")]
            Event EnterFocus()
        [Description("")]
            Event ExitFocus()
        [Description("")]
            Event Show()
        [Description("")]
            Event Hide()

        [Unimplemented]
            Event AccessKeyPress(KeyAscii As Integer)
        
            Event AmbientChanged(PropertyName As String)
        [Unimplemented]
            Event AsyncReadComplete(AsyncProp As AsyncProperty)
        [Unimplemented]
            Event AsyncReadProgress(AsyncProp As AsyncProperty)

        Event HitTest(X As Single, Y As Single, HitResult As Integer)
        [Unimplemented]
            Event GetDataMember(DataMember As String, Data As Object)
        Event MouseWheel(ByVal Delta As Integer, ByVal Horizontal As Boolean) ' new to tB
        [Description("This event only fires when the application is per-monitor DPI aware (PROCESS_PER_MONITOR_DPI_AWARE)")]
        Event DPIChange(ByVal NewDPI As Long)
        [Description("Fires for any Verbs triggered in the host application")]
        Event VerbInvoked(ByVal Verb As String)
            
        #If LOG_USERCONTROL Then
            Event ExperimentalLog(ByVal Text As String)
        #End If
        
    #End Region
               
    #Region "MEMBERS"
            
        Protected InternalState As UcInternalState
        Protected IsTerminating As Boolean
        
        [CustomDesigner("designer_PropertyPages")]
        Public PropertyPages() As String
        
        Public Verbs() As String
        
        Protected Sub Class_Terminate()
            'MsgBox "UserControl.Class_Terminate"
            #If LOG_TERMINATE Then
            Debug.Print CurrentComponentName & ".Class_Terminate"
            #End If
            ' FIXME Temporary fix
            IsTerminating = True
        End Sub
        
                
        ' Protected Sub Class_BeforeFirstMethodAccess()
        '     ' If Me.Extender IsNot Nothing Then
        '     '     Debug.Print Me.Extender.Name & "." & CurrentProcedureName & " *** UC"
        '     ' Else
        '     '     Debug.Print CurrentComponentName & "." & CurrentProcedureName & " *** UC"
        '     ' End If
        '    'Stop
           
        '     If IsTerminating = True Then Exit Sub

        '     Exit Sub    ' REMOVE ME AFTER Inherits BeforeFirstMethodAccess bug is resolved                

        '     If InternalState.IsLoaded = False Then
        '         DoLoadNow()
        '     End If
        ' End Sub
        
        
        
        ' Protected Sub HandleCreate() _
        '         Handles RootWindowElementBase.Create
            
        '     InitializeMe()
        ' End Sub
        
        Protected Sub HandleInitialize(ByVal ControlContext As ControlContext) _
                Implements IWindowsControl.Initialize
            
            'InternalSleep(5000)
            
            'Debug.Print "UserControl.HandleInitialize.0"
            Me.InternalStateResetRect()     ' resets all the base class state()
            'ResetUcInternalState(InternalState)
            #If FEATURE_OLEDRAGDROP Then
            Me.InternalStateResetOLEDragDrop()
            #End If
            Me.InternalStateResetGraphics()
            'Debug.Print "UserControl.HandleInitialize.1"
                                    
            Dim SerializeInfo As Any = ControlContext.RuntimeUICtxGetSerializer()
            
            'Debug.Print CurrentComponentName & "." & CurrentProcedureName                
            ' grab the outer class CLSID, as we will be needing it
            'InternalState.RootCLSID = .GetRootCLSID
            
            ' We could handle this better if we had full inheritance support
            ' This is needed to make properties on the outer interface accessible at design time in property lists etc.
            'Dim rootObject As Any = SerializeInfo.RuntimeUISrzGetRootClassDispatch()
            
            ' this is now done in PreInitialize() to fix accesing myUc.UserControl.Control inside UserControl_Initialize event
            'CType(Of ITwinBasicInternalClassSupport)(Me).OverrideDispatchHandler rootObject  ' this causes a circular reference that needs to be manually broken in IOleObject_Close
            
            'Debug.TracePrint "UserControl.Initialize.GetRootClassDispatch: " & ObjPtr(rootObject) & ", TypeName: " & TypeName(rootObject)
            
            ' If TypeName(rootObject) = "pdSearchBar" Then
            '     Stop
            ' End If
            
            ' FIXME Deserializing here is not quite correct for proper VB6 back compat
            ' (it needs to be done on first access to any member, and again on NEXT member access AFTER a close in a re-open scenario)
            If Not SerializeInfo.RuntimeUISrzDeserialize(Me) Then
                BackColor = SystemColorConstants.vbButtonFace
            End If
            
            InternalState.IsDesignMode = SerializeInfo.RuntimeUISrzIsDesignMode()
            InternalState.IsTbDebugging = App.IsInIDE 'RootWindowElementBase.RuntimeUISrzIsTbDebugging(SerializeInfo)
            
            'MsgBox "InternalState.IsDesignMode: " & InternalState.IsDesignMode
            'MsgBox "InternalState.IsTbDebugging: " & InternalState.IsTbDebugging
            
            'Debug.Print "UserControl.HandleInitialize.2"
            Debug.TracePrint "UserControl.HandleInitialize.2"
            
            SyncPictureINIT()
            
            'InternalSleep(5000)
            
            With InternalBaseControlInfo
                .CanGetFocus = Me.CanGetFocusINIT
                .BaseGraphicsInfoPtr = InitBaseGraphicsInfo()
            End With
            
            'Debug.Print "UserControl.HandleInitialize.3"
            Debug.TracePrint "UserControl.HandleInitialize.3"
            
            Dim miscStatus As Long
            GetClasInstanceAxMiscFlags([_HiddenModule].GetInheritedOwner(Me), miscStatus)()
            
            Dim InitData As WindowCreationData
            InitData.WindowAtomIdx = CInt(If(GraphicsBase.HasDC = True, EnumWindowAtoms.AtomIdx_ThunderUserControlDC, EnumWindowAtoms.AtomIdx_ThunderUserControl))
            InitData.WindowStyles = If(GraphicsBase.ClipControls = True, WS_CLIPCHILDREN, 0&)
            InitData.Flags = If(miscStatus And OLEMISC_SIMPLEFRAME, NeedsPrePostMessages, 0&) Or _
                                IsUserControl Or _
                                ManualMouseCapture Or _
                                ForwardMouseDown Or _
                                ForwardMouseMove Or _
                                ForwardMouseUp Or _
                                ForwardButtonClick Or _
                                ForwardDoubleClick Or _
                                ForwardKeyDown Or _
                                ForwardKeyUp Or _
                                ForwardKeyPress Or _
                                ScaleAdjustMouseEvents
            'Debug.Print "UserControl.Initialize CreateRootWindowElementBase"
            CreateRootWindowElement(ControlContext, InitData)
            RootWindowElementBase.RuntimeUISetAndSinkEvents(Me)
            
            InitGraphics(RootWindowElementBase)
            #If FEATURE_OLEDRAGDROP Then
            InitOleDragDropHelper()
            #End If
            Debug.TracePrint "UserControl.HandleInitialize.4"
            
            'Debug.Print "UserControl.HandleInitialize.4"
            
           ' With InternalBaseControlInfo
                ' These will be used for the HWND (CreateWindowEx)
                ' These won't necessarily be the final correct width/height as we don't yet know the DPI of the HWND until it is created
                ' At this stage, ScaleX/Y will assume 96dpi as the HWND isn't available.
                '.PixelsWidth = RootWindowElementBase.ScaleX(InternalState.[_ExtentX], vbHimetric, vbPixels)
                '.PixelsHeight = RootWindowElementBase.ScaleY(InternalState.[_ExtentY], vbHimetric, vbPixels)
                'Debug.Print "UserControl.Initialize PixelsWidth:=" & .PixelsWidth & " (" & InternalState.[_ExtentX] & ")"
                'Debug.Print "UserControl.Initialize PixelsHeight:=" & .PixelsHeight & " (" & InternalState.[_ExtentY] & ")"
            'End With
            
            'Debug.Print "UserControl.HandleInitialize.5"
           ' InternalSleep(1000)
        End Sub
                
        Protected Sub HandleDPIChange(ByVal newDPI As Long) _
                Implements IWindowElementEventsCommon.DPIChange
            RaiseEvent DPIChange(newDPI)
        End Sub
        
        #If FEATURE_OLEDRAGDROP Then
        Protected Sub InitOleDragDropHelper()
            OLEDragDropInit(True, False, False)
        End Sub
        #End If
        
        [Serialize(False)]
        Public Property Get Width() As Double
            Return ControlContext.RuntimeUICtxGetScaledWidth()
        End Property
        
        [Serialize(False)]
        Public Property Let Width(ByVal Value As Double)
            If Value <> Width Then
                ControlContext.RuntimeUICtxSetScaledWidth(Value)
                
                Dim HasFinishedLoading As Boolean = Me.InternalState.HasFinishedLoading
                Me.InternalState.IgnorePropertyChangedNotifications += (HasFinishedLoading = False)
                
                If InternalState.IsTbDebugging = False Then
                    On Error Resume Next
                End If
                If InternalState.IsInResizeEvent = False Then
                    InternalState.IsInResizeEvent = True
                    If InternalState.HasFinishedLoading Then
                        InternalState.HasRaisedInitialResizeEvent = True
                        RaiseEvent Resize()
                    End If
                    InternalState.IsInResizeEvent = False
                End If
                Me.InternalState.IgnorePropertyChangedNotifications -= (HasFinishedLoading = False)
                
                If Me.Ambient.UserMode = False Then
                    If InternalState.IsSettingInitialSize = True Then
                        InternalState.ChangedSizeDuringInitialResizeEvent = True
                    Else
                        ' update the designer.  probably a better way to do this, but this works on all known hosts
                        SetExtenderWidthWithCorrection(Value)
                    End If
                End If
            End If
        End Property
                
        Protected Sub SetExtenderWidthWithCorrection(ByVal Value As Double)
            On Error GoTo ErrorHandler
            Dim targetPixelWidth As Long = CLng(Me.ScaleX(CSng(Value), vbTwips, vbPixels))
             
            Dim expectedHimetricValue As Double = ScaleX(CSng(targetPixelWidth), vbPixels, vbHimetric)
            InternalState.[_ExtentX] = expectedHimetricValue
            'Debug.TracePrint "uc.Extender.Width(BEFORE): " & Extender.Width
        
            InternalIgnoreSetExtent = True
            Extender.Width = 0
            InternalIgnoreSetExtent = False
        
            'Debug.TracePrint "uc.Extender.Width(AFTER): " & Extender.Width
            If Extender.Width = 0 Then
                'MsgBox "Setting Width via Extender"
                ' Probably MS Access.  There is no bug in MS Access extender Width/Height with regard to DPI, so we can just set it
                Extender.Width = ScaleX(CSng(targetPixelWidth), vbPixels, vbContainerSize)
                Exit Sub
            Else
                ' Excel will have picked up the new size via GetExtent(), which avoids the bad uc.Extender.Width/Height implementatations
            End If
            
            Dim inPlaceSite As Any = CType(Of IOleInPlaceSite)(Me.InternalState.OleClientSite)
            Dim posRectNow As tbRECT
            Dim clipRect As tbRECT
            Dim frameInfoIgnored As OLEINPLACEFRAMEINFO
            inPlaceSite.GetWindowContext(Nothing, Nothing, posRectNow, clipRect, frameInfoIgnored)
            Dim actualPixelWidth As Long = posRectNow.Right - posRectNow.Left
            'Debug.TracePrint "contextWidth(AFTER): " & (posRectNow.Right - posRectNow.Left)
            
            If targetPixelWidth <> actualPixelWidth Then
                Dim correctionFactor As Double = actualPixelWidth / targetPixelWidth
                expectedHimetricValue /= correctionFactor
                
                InternalState.[_ExtentX] = expectedHimetricValue
                InternalIgnoreSetExtent = True
                Extender.Width = 0
                InternalIgnoreSetExtent = False
            End If
        ErrorHandler:
            InternalIgnoreSetExtent = False
        End Sub
        
        Protected Sub SetExtenderHeightWithCorrection(ByVal Value As Double)
            On Error GoTo ErrorHandler
            Dim targetPixelHeight As Long = CLng(Me.ScaleY(CSng(Value), vbTwips, vbPixels))
                
            Dim expectedHimetricValue As Double = ScaleY(CSng(targetPixelHeight), vbPixels, vbHimetric)
            InternalState.[_ExtentY] = expectedHimetricValue
            
            InternalIgnoreSetExtent = True
            Extender.Height = 0
            InternalIgnoreSetExtent = False
            
            'Debug.TracePrint "uc.Extender.Height(AFTER): " & Extender.Height
            If Extender.Height = 0 Then
                'MsgBox "Setting Height via Extender"
                ' Probably MS Access.  There is no bug in MS Access extender Width/Height with regard to DPI, so we can just set it
                Extender.Height = ScaleY(CSng(targetPixelHeight), vbPixels, vbContainerSize)
                Exit Sub
            Else
                ' Excel will have picked up the new size via GetExtent(), which avoids the bad uc.Extender.Width/Height implementatations
            End If
                
            Dim inPlaceSite As Any = CType(Of IOleInPlaceSite)(Me.InternalState.OleClientSite)
            Dim posRectNow As tbRECT
            Dim clipRect As tbRECT
            Dim frameInfoIgnored As OLEINPLACEFRAMEINFO
            inPlaceSite.GetWindowContext(Nothing, Nothing, posRectNow, clipRect, frameInfoIgnored)
            Dim actualPixelHeight As Long = posRectNow.Bottom - posRectNow.Top
            'Debug.TracePrint "contextHeight(AFTER): " & actualPixelHeight
                
            If targetPixelHeight <> actualPixelHeight Then
                Dim correctionFactor As Double = actualPixelHeight / targetPixelHeight
                expectedHimetricValue /= correctionFactor
                    
                InternalState.[_ExtentY] = expectedHimetricValue
                InternalIgnoreSetExtent = True
                Extender.Height = 0
                InternalIgnoreSetExtent = False
            End If
        ErrorHandler:
            InternalIgnoreSetExtent = False
        End Sub
        
        [Serialize(False)]
        Public Property Get Height() As Double
            Return ControlContext.RuntimeUICtxGetScaledHeight()
        End Property
        
        [Serialize(False)]
        Public Property Let Height(ByVal Value As Double)
            If Value <> Height Then
                ControlContext.RuntimeUICtxSetScaledHeight(Value)
                Dim HasFinishedLoading As Boolean = Me.InternalState.HasFinishedLoading
                Me.InternalState.IgnorePropertyChangedNotifications += (HasFinishedLoading = False)
                If InternalState.IsTbDebugging = False Then
                    On Error Resume Next
                End If
                If InternalState.IsInResizeEvent = False Then
                    InternalState.IsInResizeEvent = True
                    If InternalState.HasFinishedLoading Then
                        InternalState.HasRaisedInitialResizeEvent = True
                        RaiseEvent Resize()
                    End If
                    InternalState.IsInResizeEvent = False
                End If
                Me.InternalState.IgnorePropertyChangedNotifications -= (HasFinishedLoading = False)
                
                If Me.Ambient.UserMode = False Then
                    If InternalState.IsSettingInitialSize = True Then
                        InternalState.ChangedSizeDuringInitialResizeEvent = True
                    Else
                        ' update the designer
                        SetExtenderHeightWithCorrection(Value)
                    End If
                End If
            End If
        End Property
        
        Protected Sub InitializeMe()
                        
            'Debug.Print Me.Extender.Name & "." & CurrentProcedureName()
            #If LOG_USERCONTROL Then
                Log("InitializeMe")
            #End If
            'Debug.TracePrint "InitializeMe.1"
            InternalState.IsInitialized = True
            
            ' for the Initialize event, there's no need to have the final size of the control
            ' the ScaleWidth/Height etc should be based off the design-time size of the designed control
            'Stop
            
            If InternalState.IsLoaded = False Then
                Dim outer As UserControl
                Set outer = CType(Of UserControl)([_HiddenModule].GetInheritedOwner(Me))
                UnprotectedAccess(outer).DoLoadNow()
            End If
            
            ' If Not Me.InternalState.IsInitialized1 Then
            '      Me.InternalState.IsInitialized1 = True
            '      Me.InternalState.IgnorePropertyChangedNotifications += 1
            '      If InternalState.IsTbDebugging = False Then
            '          On Error Resume Next
            '      End If
            '      Debug.TracePrint "InitializeMe.7"
            '      'RaiseEvent Initialize()
            '      Debug.TracePrint "InitializeMe.8"
                 
            '      Me.InternalState.IgnorePropertyChangedNotifications -= 1
            ' End If
             #If LOG_USERCONTROL Then
                Log("InitializeMe (3)")
             #End If
            On Error Resume Next
            
            Debug.TracePrint "InitializeMe.9"
            Dim OleClientSite As Any = Me.InternalState.OleClientSite
            Debug.TracePrint "InitializeMe.10"
            If OleClientSite IsNot Nothing Then OleClientSite.RequestNewObjectLayout()  ' MSACCESS errors on this
            Debug.TracePrint "InitializeMe.11"
            
            #If LOG_USERCONTROL Then
                Log("InitializeMe (4)")
            #End If
        End Sub
        
        Protected Sub HandlePreLoad() _
                Implements IWindowElementEventsCommonRoot.PreLoadForm
            
            'Debug.Print CurrentComponentName & "." & CurrentProcedureName

            ' At this point the HWND is available, but not correct size etc.     
            Dim outer As UserControl
            Set outer = CType(Of UserControl)([_HiddenModule].GetInheritedOwner(Me))
            UnprotectedAccess(outer).DoLoadNow()                ' this is needed here, at least at design time, otherwise things like resizing the control won't work
            
            SyncScaleMode(Me, Me.RootWindowElementBase)
            #If FEATURE_OLEDRAGDROP Then
            SyncOLEDropMode()
            #End If
            
            #If FEATURE_DRAWING Then
            InternalSyncFontProperties(True, True)
            #End If
        End Sub
                
        Protected Sub HandleDestroy() _
                Implements IWindowsControl.Destroy
            'MsgBox "Uc Handle Destroy"
            
            #If LOG_TERMINATE Then
                Debug.Print CurrentComponentName & "." & CurrentProcedureName
            #End If
            
            #If LOG_USERCONTROL Then
                Log("HandleDestroy")
            #End If
            
            ' disconnect anything that causes a circular reference here
            'Debug.Print "UserControl.HandleDestroy"
            #If FEATURE_OLEDRAGDROP Then
            Me.InternalStateResetOLEDragDrop()
            #End If
            Me.InternalStateResetGraphics()
            ResetUcInternalState(InternalState)
            
            SetClassOverrideDispatch([_HiddenModule].GetInheritedOwner(Me), Nothing)        ' breaks circular ref
                        
            #If FEATURE_DRAWING Then
            Set Font = Nothing
            #End If
            
            [_HiddenModule].ResetFirstMethodAccessFlag([_HiddenModule].GetInheritedOwner(Me))
        End Sub
        
        Protected Sub HandleMouseWheel(ByVal Delta As Integer, ByVal Horizontal As Boolean) _
                Implements IWindowElementEventsCommon.MouseWheel
            
            RaiseEvent MouseWheel(Delta, Horizontal)
        End Sub
        
        Protected Sub HandleEnterFocus2() _
                Implements IWindowElementEventsUC.EnterFocus2
            
            RaiseEvent EnterFocus()
        End Sub
        
        Protected Sub HandleExitFocus2() _
                Implements IWindowElementEventsUC.ExitFocus2
            
            RaiseEvent ExitFocus()
        End Sub
        
        Protected Sub HandleEnterFocus() _
                Implements IWindowElementEventsUC.EnterFocus
                               
            #If LOG_USERCONTROL Then
                Log("HandleEnterFocus")
            #End If
            
            InternalState.hasFocusOnChild = True
            
            On Error Resume Next
            Dim controlSite As Any = CType(Of IOleControlSite)(InternalState.OleClientSite)
            #If LOG_USERCONTROL Then
                Log("HandleEnterFocus -> controlSite.OnFocus(1)")
            #End If
            controlSite.OnFocus(1)      ' this will trigger DoVerb(OLEIVERB_INPLACEACTIVATE)
            #If LOG_USERCONTROL Then
                Log("HandleEnterFocus -> controlSite.OnFocus(1)... DONE")
            #End If
                
            If InternalBaseControlInfo.EventsAreFrozen = False Then
                If InternalState.IsTbDebugging = False Then
                    On Error Resume Next
                End If
                'RaiseEvent EnterFocus()
            End If
                    
        End Sub

        Protected Sub HandlePreMessage(ByVal hwnd As LongPtr, ByVal Msg As Long, ByVal wParam As LongPtr, ByVal lParam As LongPtr, ByRef MutedReturnValue As Variant, ByRef PostMessageCookie As Long) _
                Implements IWindowElementEventsCommon.PreProcessMessage
            
            Dim IgnoredMessage As Boolean
            If InternalState.IsCreatingWindow Then
                If Msg <> WM_CREATE Then
                    IgnoredMessage = True
                    'Debug.Print "UC PRE MESSAGE (IGNORED DURING CREATEWINDOW): " & Hex(Msg)
                End If
            End If
        
            ' If Msg = WM_SHOWWINDOW Then
            '     InternalState.ActualVisibilityState = (wParam <> 0)
            ' End If
            
            If IgnoredMessage = False Then
                'Debug.Print "UC PRE MESSAGE: " & Hex(Msg)
            
                'If (Me.ControlContainer = True) And (Msg < &H400) Then   '     removed this as all messages seem to get passed on, and we now only get the HandlePreMessage for control containers due to the intialization flag NeedsPrePostMessages
                    #If LOG_USERCONTROL Then
                        Log("HandlePreMessage", Hex(Msg), Hex(wParam), Hex(lParam))
                    #End If
                    Dim simpleFrameSite As Any = CType(Of ISimpleFrameSite)(Me.InternalState.OleClientSite)
                    'Debug.TracePrint "ISimpleFrameSite: " & Hex(ObjPtr(simpleFrameSite))
                    Dim result As LongPtr
                    On Error Resume Next
                    simpleFrameSite.PreMessageFilter(Me.hWnd, Msg, wParam, lParam, result, PostMessageCookie)
                    If Err.LastHresult = S_FALSE Then
                        #If LOG_USERCONTROL Then
                            Log("HandlePreMessage", Hex(Msg), Hex(wParam), Hex(lParam), " --> MESSAGE CONSUMED (result: " & result & ")")
                        #End If
                        MutedReturnValue = result ' the site has consumbed the message
                    ElseIf Err.Number <> 0 Then
                        #If LOG_USERCONTROL Then
                            Log("HandlePreMessage", Hex(Msg), Hex(wParam), Hex(lParam), " --> MESSAGE NOT USED")
                        #End If
                        Err.ReturnHResult = E_NOTIMPL   ' PostMessage() not necessary later
                    Else
                        #If LOG_USERCONTROL Then
                            Log("HandlePreMessage", Hex(Msg), Hex(wParam), Hex(lParam), " --> MESSAGE NEEDS FURTHER PROCESSING (S_OK, interim: " & result & ")")
                        #End If
                    End If
                'End If
            End If
        End Sub

        Protected Sub HandlePostMessage(ByVal hwnd As LongPtr, ByVal Msg As Long, ByVal wParam As LongPtr, ByVal lParam As LongPtr, ByRef ReturnValue As LongPtr, ByVal PostMessageCookie As Long) _
                Implements IWindowElementEventsCommon.PostProcessMessage
            
            Dim IgnoredMessage As Boolean
            If InternalState.IsCreatingWindow Then
                If Msg <> WM_CREATE Then
                    IgnoredMessage = True
                    'Debug.Print "UC PRE MESSAGE (IGNORED DURING CREATEWINDOW): " & Hex(Msg)
                End If
            End If
            
            If IgnoredMessage = False Then
                'Debug.Print "UC POST MESSAGE: " & Hex(Msg)
                'If (Me.ControlContainer = True) And (Msg < &H400) Then   '     removed this as all messages seem to get passed on, and we now only get the HandlePreMessage for control containers due to the intialization flag NeedsPrePostMessages
                    #If LOG_USERCONTROL Then
                        Log("HandlePostMessage", Hex(Msg), Hex(wParam), Hex(lParam))
                    #End If
                    Dim simpleFrameSite As Any = CType(Of ISimpleFrameSite)(Me.InternalState.OleClientSite)
                    On Error Resume Next
                    simpleFrameSite.PostMessageFilter(Me.hWnd, Msg, wParam, lParam, ReturnValue, PostMessageCookie)
                    If Err.Number = 0 Then
                        #If LOG_USERCONTROL Then
                            Log("HandlePostMessage", Hex(Msg), Hex(wParam), Hex(lParam), " --> MESSAGE PROCESSED BY SITE (return: " & ReturnValue & ")")
                        #End If
                    Else
                        #If LOG_USERCONTROL Then
                            Log("HandlePostMessage", Hex(Msg), Hex(wParam), Hex(lParam), " --> MESSAGE NOT PROCESSED")
                        #End If
                    End If
            End If
        End Sub
        
        Protected Sub HandleImmediateGotFocus() _
                Implements IWindowElementEventsUC.ImmediateGotFocus

            If InternalState.siteFrame IsNot Nothing Then
                InternalState.siteFrame.SetActiveObject(Me, 0)
            End If
        End Sub
            
        Protected Sub HandleExitFocus() _
                Implements IWindowElementEventsUC.ExitFocus
            
            #If LOG_USERCONTROL Then
                Log("HandleExitFocus")
            #End If
            
            If InternalState.hasFocusOnChild = False Then Exit Sub
            InternalState.hasFocusOnChild = False
            
            ' FIXME ordering here not checked
            
            On Error Resume Next

            Dim OleClientSite As Any = Me.InternalState.OleClientSite
            Dim site As Any = CType(Of IOleInPlaceSite)(OleClientSite)
            site.OnUIDeactivate(0)
                
            Dim controlSite As IOleControlSite = CType(Of IOleControlSite)(OleClientSite)
            controlSite.OnFocus(0)
            
            If InternalBaseControlInfo.EventsAreFrozen = False Then
                If InternalState.IsTbDebugging = False Then
                    On Error Resume Next
                End If
                'RaiseEvent ExitFocus()
            End If
            
            If InternalState.siteFrame IsNot Nothing Then
                InternalState.siteFrame.SetActiveObject(Nothing, 0)
            End If
                        
            #If LOG_USERCONTROL Then
                Log("HandleExitFocus", "Err.Number:", Hex(Err.Number))
            #End If
        End Sub
                
        Protected Sub HandleGotFocus() _
            Implements IWindowElementEventsUC.GotFocus
            
            #If LOG_USERCONTROL Then
                Log("HandleGotFocus")
            #End If
            
            If CanGetFocus = False Then Exit Sub
            InternalState.hasFocus = True
            
            Dim site As Any = CType(Of IOleInPlaceSite)(InternalState.OleClientSite)
            #If LOG_USERCONTROL Then
                Log("HandleGotFocus -> site.OnUIActivate()")
            #End If
            
            'MsgBox IsDesignMode
            ' This can cause 'Catastrophic failure' messages (and others) in VBA UserForms in design mode if we don't catch the error here
            On Error Resume Next
            site.OnUIActivate()         ' by calling this now, prevents the next controlSite.OnFocus(1) call from triggering DoVerb(OLEIVERB_INPLACEACTIVATE)
            On Error GoTo 0
            
            #If LOG_USERCONTROL Then
                Log("HandleGotFocus -> site.OnUIActivate()... DONE")
            #End If
            If InternalState.siteFrame IsNot Nothing Then
                #If LOG_USERCONTROL Then
                    Log("HandleGotFocus -> siteFrame.SetMenu(0, 0, 0)")
                #End If
                 On Error Resume Next
                 InternalState.siteFrame.SetMenu(0, 0, 0)      ' this can throw
                 On Error GoTo 0
                #If LOG_USERCONTROL Then
                    Log("HandleGotFocus -> siteFrame.SetMenu(0, 0, 0)... DONE")
                #End If
            End If

            'Dim controlSite As Any = CType(Of IOleControlSite)(OleClientSite)
            #If LOG_USERCONTROL Then
                Log("HandleGotFocus -> controlSite.OnFocus(1)")
            #End If
            'controlSite.OnFocus(1) ' if we do this, then VBCCR.CommandButton (and many others) compiled by us don't focus properly, e.g. CommandButtonW.Click doesn't fire
            #If LOG_USERCONTROL Then
                Log("HandleGotFocus -> controlSite.OnFocus(1)")
            #End If
            
            
                            
            If InternalBaseControlInfo.EventsAreFrozen = False Then
                If InternalState.IsTbDebugging = False Then
                    On Error Resume Next
                End If
                'RaiseEvent EnterFocus()
                RaiseEvent GotFocus()
            End If
        End Sub

        Protected Sub HandleLostFocus() _
                Implements IWindowElementEventsUC.LostFocus
                            
            #If LOG_USERCONTROL Then
                Log("HandleLostFocus")
            #End If
            
            If InternalState.hasFocus = False Then Exit Sub
            If CanGetFocus = False Then Exit Sub
            InternalState.hasFocus = False
            
            ' FIXME ordering here not checked
            
            On Error Resume Next        ' added to avoid issues in Access
            Dim site As Any = CType(Of IOleInPlaceSite)(InternalState.OleClientSite)
            site.OnUIDeactivate(0)
                
            Dim controlSite As Any = CType(Of IOleControlSite)(InternalState.OleClientSite)
            controlSite.OnFocus(0)
            
            If InternalBaseControlInfo.EventsAreFrozen = False Then
                If InternalState.IsTbDebugging = False Then
                    On Error Resume Next
                End If
                RaiseEvent LostFocus()
                HandleExitFocus()
            End If
        End Sub
        
        Protected MessageHook As IGetMessageHook
        
        Protected Sub ActivateMessageHook()
            If Me.Ambient.UserMode Then
                'MsgBox "Usermode!" & RootWindowElementBase.Handle
                If (Me.PreKeyEvents = True) And (Me.Windowless = False) Then
                    Dim hwnd As LongPtr = RootWindowElementBase.RuntimeUIGetHandle()
                    If hwnd <> vbNullPtr Then
                        Set MessageHook = RuntimeCreateGetMessageHook()
                        MessageHook.RegisterMessage(hwnd, ExactWindow Or AllDescendants, CInt(WM_KEYDOWN), AddressOf OnMessageHookKeyDown)
                        MessageHook.RegisterMessage(hwnd, ExactWindow Or AllDescendants, CInt(WM_KEYUP), AddressOf OnMessageHookKeyUp)
                        MessageHook.RegisterMessage(hwnd, ExactWindow Or AllDescendants, CInt(WM_SETFOCUS), AddressOf OnMessageHookGotFocusWithin)
                        MessageHook.RegisterMessage(hwnd, ExactWindow Or AllDescendants, CInt(WM_KILLFOCUS), AddressOf OnMessageHookLostFocusWithin)
                        MessageHook.Start
                    End If
                End If
            End If
        End Sub
        
        Protected Sub DeactivateMessageHook()
            If MessageHook IsNot Nothing Then
                MessageHook.Stop()
                Set MessageHook = Nothing
            End If
        End Sub
         
        [Serialize(False)]
        [Description("Populated for the PreKeyDown/PreKeyUp events")]
        Public PreKeyWParam As LongPtr
        [Serialize(False)]
        [Description("Populated for the PreKeyDown/PreKeyUp events")]
        Public PreKeyLParam As LongPtr
        [Serialize(False)]
        [Description("Populated for the PreKeyDown/PreKeyUp events")]
        Public PreKeyTargetHwnd As LongPtr
        
        Protected IsActive As Boolean
        Protected Function OnMessageHookGotFocusWithin(msg As HookMSG) As LongPtr
            ' This event is fired even when a natively created child control of ours receives the focus
            'Debug.TracePrint "OnMessageHook_GotFocusWithin"
            On Error Resume Next
            If IsActive = False Then
                InternalState.siteDoc.SetActiveObject(Me, 0)
                'Dim lastErr As Any = Err.LastHresult
                'Debug.TracePrint "SetActiveObject " & lastErr
                IsActive = True
            End If
        End Function
        
        Protected Function OnMessageHookLostFocusWithin(msg As HookMSG) As LongPtr
            'Debug.TracePrint "OnMessageHook_LostFocusWithin"
            On Error Resume Next
            If IsActive Then
                InternalState.siteDoc.SetActiveObject(Nothing, 0)
                IsActive = False
            End If
        End Function
                        
        Protected MuteNextKeyInTranslateAccel As Boolean
        Protected Function OnMessageHookKeyDown(msg As HookMSG) As LongPtr
            Dim shiftState As Integer
            Dim keyCode As Integer = CInt(msg.wParam)
            If USER32.GetKeyState(vbKeyShift) And 80000000& Then shiftState += CInt(vbShiftMask)
            If USER32.GetKeyState(vbKeyMenu) And 80000000& Then shiftState += CInt(vbAltMask)
            If USER32.GetKeyState(vbKeyControl) And 80000000& Then shiftState += CInt(vbCtrlMask)
            PreKeyTargetHwnd = msg.hwnd
            PreKeyWParam = msg.wParam
            PreKeyLParam = msg.lParam
            RaiseEvent PreKeyDown(keyCode, shiftState)
            
            'If PreKeyWParam = vbKeyA Then
            '    MsgBox "preKey result   " & PreKeyWParam & " --> " & keyCode
            'End If
            PreKeyWParam = 0
            PreKeyLParam = 0
            PreKeyTargetHwnd = 0
            MuteNextKeyInTranslateAccel = False
            If keyCode = 0 Then
                msg.message = 0
                MuteNextKeyInTranslateAccel = True
                Return 1
            End If
        End Function
        
        Protected Function OnMessageHookKeyUp(msg As HookMSG) As LongPtr
            Dim shiftState As Integer
            Dim keyCode As Integer = CInt(msg.wParam)
            If USER32.GetKeyState(vbKeyShift) And 80000000& Then shiftState += CInt(vbShiftMask)
            If USER32.GetKeyState(vbKeyMenu) And 80000000& Then shiftState += CInt(vbAltMask)
            If USER32.GetKeyState(vbKeyControl) And 80000000& Then shiftState += CInt(vbCtrlMask)
            PreKeyTargetHwnd = msg.hwnd
            PreKeyWParam = msg.wParam
            PreKeyLParam = msg.lParam
            RaiseEvent PreKeyUp(keyCode, shiftState)
            PreKeyWParam = 0
            PreKeyLParam = 0
            PreKeyTargetHwnd = 0
            If keyCode = 0 Then
                msg.message = 0
                Return 1
            End If
        End Function
                
        Protected Sub HandleLoad() _
                Implements IWindowElementEventsCommon.Load

            InternalState.IsLoaded = True
            InternalState.OriginalParentHWND = InternalHWND.GetParent()
            #If LOG_USERCONTROL Then
                Log("HandleLoad")
            #End If
        
            ActivateMessageHook()
        End Sub
        
        Protected Sub SetPendingPopupMenu(Menu As Menu) _
                Implements ITbCommonContainerPrivate.SetPendingPopupMenu
        End Sub
        
        Protected Sub MenuRedrawRequired() _
                Implements ITbCommonContainerPrivate.MenuRedrawRequired
        End Sub
        
        Protected Sub InternalRaiseResize() _
                Implements ITbCommonContainerPrivate.RaiseResize
            
            # If LOG_USERCONTROL Then
                Log("InternalRaiseResize")
            #End If
            
        	If InternalState.MutedResizeEventsCount = 0 Then
                Dim HasFinishedLoading As Boolean = Me.InternalState.HasFinishedLoading
                Me.InternalState.IgnorePropertyChangedNotifications += (HasFinishedLoading = False)
                If InternalState.IsTbDebugging = False Then
                    On Error Resume Next
                End If
                If InternalState.IsInResizeEvent = False Then
                    InternalState.IsInResizeEvent = True
                    If InternalState.HasFinishedLoading Then
                        InternalState.HasRaisedInitialResizeEvent = True
                        RaiseEvent Resize()
                    End If
                    InternalState.IsInResizeEvent = False
                End If
                Me.InternalState.IgnorePropertyChangedNotifications -= (HasFinishedLoading = False)
                InternalState.InitialResizeEventFired = True
            End If
        End Sub
        
        Protected Sub InternalRaiseResize2() _
                Implements ITbCommonContainerPrivate.RaiseResize2
            
            'If InternalState.MutedResizeEventsCount <> 0 Then
            '    MsgBox InternalState.MutedResizeEventsCount, , "InternalState.MutedResizeEventsCount"
            'End If
            
            If InternalState.IsTbDebugging = False Then
                On Error Resume Next
            End If
            If InternalState.IsInResizeEvent = False Then
                InternalState.IsInResizeEvent = True
                If InternalState.HasFinishedLoading Then
                    InternalState.HasRaisedInitialResizeEvent = True
                    RaiseEvent Resize()
                End If
                InternalState.IsInResizeEvent = False
            End If
        End Sub

        Protected Sub InternalRaisePaint() _
                Implements ITbCommonContainerPrivate.RaisePaint
            
            If InternalState.IsTbDebugging = False Then
                On Error Resume Next
            End If
        	RaiseEvent Paint()
            Debug.TracePrint "*** UC.InternalRaisePaint DONE"
        End Sub
        
        Protected Sub HandleEraseBackground(ByVal hdc As HDC, ByRef Handled As Boolean) _
                Implements IWindowElementEventsCommon.EraseBackground
                
            #If LOG_USERCONTROL Then
                Log("HandleEraseBackground")
            #End If
            If InternalState.IsHandlingPaint = False Then
                'If InternalState.IsInitialized = False Then InitializeMe
            
                Dim preservedDC As Any = Me.InternalHDC
                Me.InternalHDC.Value = hdc
                Me.Cls
                Me.InternalHDC.Value = preservedDC
                Handled = True     ' swallow up the event
            End If
        End Sub
        
        Protected Sub HandlePaint(ByRef Handled As Boolean) _
                Implements IWindowElementEventsCommon.Paint
                
           ' If InternalState.IsInitialized = False Then InitializeMe
            
            #If LOG_USERCONTROL Then
                Log("HandlePaint")
            #End If
            
            InternalState.IsHandlingPaint = True
            
            Dim ps As PAINTSTRUCT
            Dim RootWindowElementBase As Any = Me.RootWindowElementBase
            RootWindowElementBase.RuntimeUIBeginPaint(ps)    ' you MUST use this method, and NOT the BeginPaint API 
                
            #If LOG_USERCONTROL Then
                Log("HandlePaint", "ps.hdc: ", Hex(ps.hdc), "GetDC():", GetDC(hWnd))
            #End If
                
                OnPaint(ps.hdc)
                
                ' If Me.ClipControls = True And IsDesignMode = False Then
                '     ' FIXME need better method.
                '     Dim Ctrl As Control
                '     For Each Ctrl In Me.Parent.Controls
                '         On Error Resume Next
                '             Dim isContainedByUs As Boolean = False
                '             isContainedByUs = Ctrl.Container Is Me
                '             If isContainedByUs Then
                '                 WindowsAPI.RedrawWindow(Ctrl.Hwnd, 0, 0, RDW_ERASE Or RDW_INVALIDATE Or RDW_ERASENOW Or RDW_UPDATENOW Or RDW_FRAME)
                '             End If
                '     Next
                '     On Error GoTo 0
                ' End If

            'ValidateRect(Me.hWnd, 0)
            RootWindowElementBase.RuntimeUIEndPaint(ps)
            'Handled = True     ' We purposely DONT swallow up the event, as the extenders WM_PAINT post-filter can render onto the window (e.g. lightweight controls)
            
            InternalState.IsHandlingPaint = False
            
            #If LOG_USERCONTROL Then
                Log("HandlePaint.... DONE")
            #End If
        End Sub
                                        
        [Serialize(False)]
        Public Property Get hWnd() As LongPtr                           ' FIXME change to HWND once ALIAS is aligned
            If Me.InternalState.IsWindowlessActivated Then Return 0
            Return RootWindowElementBase.RuntimeUIGetHandle()
        End Property
        
        Protected Property Get InternalHWND() As HWND
            If Me.InternalState.IsWindowlessActivated Then Return 0
            Return RootWindowElementBase.RuntimeUIGetHandle()
        End Property
                    
        [Serialize(False)]
        Public Property Get DpiScale() As Double
            Return RootWindowElementBase.RuntimeUIGetDPI() / 96
        End Property
        
        Public Sub PropertyChanged(Optional ByVal PropertyName As Variant)
            If Me.InternalState.IgnorePropertyChangedNotifications = 0 Then
                InternalState.PropertiesChanged = True
                
                ' FIXME this is for initial support of OLE_OPTEXCLUSIVE in UserControls (VBCCR.OptionButtonW), but needs to be expanded.
                ' Get the DISPID of the property from the outer class and raise the IPropertyNotifySink::OnChanged event
                If InternalState.IsLoaded And (Len(PropertyName) > 0) Then
                    'Dim outerClass As IDispatchInternal
                    Const DISPID_UNKNOWN As Long = -1
                    Dim dispID As Long = DISPID_UNKNOWN
                    Dim GUID_NULL As InternalIID
                    
                    On Error Resume Next
                        Dim SerializeInfo As SerializeInfo
                        SerializeInfo.Pointer = GetClassInstanceSerializer([_HiddenModule].GetInheritedOwner(Me))
                        Dim outerClass As Any = SerializeInfo.RuntimeUISrzGetRootClassDispatch()
                        outerClass.GetIDsOfNames(GUID_NULL, CStr(PropertyName), 1, 0, dispID)
                        If dispID <> DISPID_UNKNOWN Then
                            RuntimeRaisePropertyNotifySinkChangedEvent(outerClass, dispID)
                        End If
                End If
            End If
        End Sub
        
    #End Region
    
    #If LOG_USERCONTROL Then
        Protected Sub Log(ParamArray Values() As Variant)
            'MsgBox Format(Now, "hh:nn:ss") & " " & Join(Values, ", ")
            RaiseEvent ExperimentalLog(Format(Now, "hh:nn:ss") & " " & Join(Values, ", "))
        End Sub
    #End If
    
    Protected Sub IOleObjectSetClientSite(ByVal pClientSite As IOleClientSite) _
            Implements IOleObject.SetClientSite
        #If LOG_USERCONTROL Then
            Log("IOleObject_SetClientSite", ObjPtr(pClientSite))
        #End If
        
        'Debug.TracePrint "RefCount: " & GetClassInstanceRefCount(Me)
        'Debug.Print "UserControl IOleObject_SetClientSite"
        
        Debug.TracePrint "IOleObject_SetClientSite", Hex(ObjPtr(pClientSite))
        'IOleObject_SetClientSite_WasCalled = True
        Set InternalState.OleClientSite = pClientSite
        Set InternalState.CachedExtender = Nothing
        #If LOG_USERCONTROL Then
            Log("IOleObject_SetClientSite ... DONE", ObjPtr(pClientSite))
        #End If
        
        ' VB6 calls into GetMiscStatus() on itself here, presumably to cache its own flags, but we don't need to do that.
        
        'InitializeMe
    End Sub
    
    Protected Sub IOleObjectGetClientSite(ppClientSite As IOleClientSite) _
            Implements IOleObject.GetClientSite
        #If LOG_USERCONTROL Then
            Log("IOleObject_GetClientSite")
        #End If
        PutMemPtr(VarPtr(ppClientSite), vbNullPtr)    ' OUT semantics            
        Set ppClientSite = InternalState.OleClientSite
        
        If ppClientSite Is Nothing Then
            Err.ReturnHResult = &H800AFFFF  ' must return an error, so that the caller doesn't assume we populated ppClientSite and cause a nullptr deref
        End If
    End Sub
    
    Protected Sub IOleObjectSetHostNames(ByVal szContainerApp As LongPtr, ByVal szContainerObj As LongPtr) _
            Implements IOleObject.SetHostNames
        #If LOG_USERCONTROL Then
            Log("IOleObject_SetHostNames", szContainerApp, szContainerObj)
        #End If
        ' MSACCESS calls this during initialization.  VBx doesn't.  Empty implementation is correct.
    End Sub
    
    Protected Sub IOleObjectClose(ByVal dwSaveOption As Long) _
            Implements IOleObject.Close
        #If LOG_USERCONTROL Then
            Log("IOleObject_Close", dwSaveOption)
        #End If
               
        'Dim CachedExtenderObjPtr As LongPtr
        'GetMemPtr(VarPtr(InternalState.CachedExtender), CachedExtenderObjPtr)      'ObjPtr without implicit AddRef/Release
        'MsgBox "IOleObjectClose InternalState.CachedExtender-PTR: " & Hex(CachedExtenderObjPtr)
        'MsgBox "IOleObjectClose InternalState.CachedExtender: " & TypeName(InternalState.CachedExtender)
        
        Debug.TracePrint "IOleObject_Close", dwSaveOption, "InternalState.IsClosed: " & InternalState.IsClosed
                
        If InternalState.IsClosed Then Exit Sub
        InternalState.IsClosed = True
        
        'MsgBox "IOleObject_Close"
        
        ' FIXME at what point should the timers actually stop?
        Debug.TracePrint "IOleObject_Close StopTimers()..."
        Dim RootWindowElementBase As Any = Me.RootWindowElementBase
        RootWindowElementBase.RuntimeUIStopTimers()
        Debug.TracePrint "IOleObject_Close StopTimers()... DONE"
        
        If InternalState.IsTbDebugging = False Then
            On Error Resume Next
        End If
        RaiseEvent Terminate()

        ' ' FIXME at what point does the window actually get hidden, and detached?
        Dim _hwnd As Any = RootWindowElementBase.RuntimeUIGetHandle()
        If _hwnd.Value <> 0 Then
            _hwnd.ShowWindow(SW_HIDE)
            _hwnd.SetParent(0)
            InternalState.HwndIsParented = False
        End If
                
        Set InternalState.OleClientSite = Nothing
        Set InternalState.CachedExtender = Nothing
        
        DeactivateMessageHook()
        
        ' FIXME should the window actually get destroyed at this point?
        RootWindowElementBase.RuntimeUIDestroyHandle()          ' This causes IWindowsControl.Destroy to be hit (via WM_DESTROY)

    End Sub
    
    Protected Sub IOleObjectSetMoniker(ByVal dwWhichMoniker As Long, ByVal pmk As VBRUN.tbInternal_IMoniker) _
            Implements IOleObject.SetMoniker
        #If LOG_USERCONTROL Then
            Log("IOleObject_SetMoniker", dwWhichMoniker, ObjPtr(pmk))
        #End If
        Err.ReturnHResult = E_NOTIMPL        ' Correct implementation
    End Sub
    
    Protected Sub IOleObjectGetMoniker(ByVal dwAssign As Long, ByVal dwWhichMoniker As Long, pmk As VBRUN.tbInternal_IMoniker) _
            Implements IOleObject.GetMoniker
        #If LOG_USERCONTROL Then
            Log("IOleObject_GetMoniker", dwAssign, dwWhichMoniker)
        #End If
        PutMemPtr(VarPtr(pmk), vbNullPtr)    ' OUT semantics            
        Err.ReturnHResult = E_NOTIMPL        ' Correct implementation
    End Sub
    
    Protected Sub IOleObjectInitFromData(ByVal pDataObject As VBRUN.tbInternal_IDataObject, ByVal fCreation As Long, ByVal dwReserved As Long) _
            Implements IOleObject.InitFromData
        #If LOG_USERCONTROL Then
            Log("IOleObject_InitFromData", ObjPtr(pDataObject), fCreation, dwReserved)
        #End If
        Err.ReturnHResult = E_NOTIMPL        ' Correct implementation
    End Sub
    
    Protected Sub IOleObjectGetClipboardData(ByVal dwReserved As Long, ppDataObject As VBRUN.tbInternal_IDataObject) _
            Implements IOleObject.GetClipboardData
        #If LOG_USERCONTROL Then
            Log("IOleObject_GetClipboardData", dwReserved, ObjPtr(ppDataObject))
        #End If
        PutMemPtr(VarPtr(ppDataObject), vbNullPtr)    ' OUT semantics            
        Err.ReturnHResult = E_NOTIMPL        ' Correct implementation
    End Sub
    
    Protected Sub IOleObjectEnumVerbs(ByRef ppEnumOleVerb As IEnumOLEVERB) _
            Implements IOleObject.EnumVerbs
        'MsgBox "IOleObject_EnumVerbs"
        #If LOG_USERCONTROL Then
            Log("IOleObject_EnumVerbs", ObjPtr(ppEnumOleVerb))
        #End If
        PutMemPtr(VarPtr(ppEnumOleVerb), vbNullPtr)    ' OUT semantics
        
        Set ppEnumOleVerb = New UcVerbEnumerator(Me)
        'MsgBox "EnumVerbs"
        'Err.ReturnHResult = E_NOTIMPL        ' FIXME this is not the correct implementation
    End Sub
    
    [Serialize(False)]
    Protected Property Get WindowlessRectLeft() As Long _
            Implements TbUserControlPrivate.WindowlessRectLeft
        Return InternalState.WindowlessRect.Left
    End Property
    [Serialize(False)]
    Protected Property Get WindowlessRectTop() As Long _
            Implements TbUserControlPrivate.WindowlessRectTop
        Return InternalState.WindowlessRect.Top
    End Property
    [Serialize(False)]
    Protected Property Get WindowlessRectRight() As Long _
            Implements TbUserControlPrivate.WindowlessRectRight
        Return InternalState.WindowlessRect.Right
    End Property
    [Serialize(False)]
    Protected Property Get WindowlessRectBottom() As Long _
            Implements TbUserControlPrivate.WindowlessRectBottom
        Return InternalState.WindowlessRect.Bottom
    End Property
        
    Protected Sub IOleObjectDoVerb(ByVal iVerb As Long, ByVal lpmsg As LongPtr, ByVal pActiveSite As IOleClientSite, ByVal lindex As Long, ByVal hwndParent As HWND, ByRef lprcPosRect As tbRECT) _
            Implements IOleObject.DoVerb
        
        'Debug.Print "UserControl IOleObject_DoVerb", iVerb, lpmsg, , ObjPtr(pActiveSite), lindex, Hex(hwndParent), lprcPosRect.Left & "," & lprcPosRect.Top & "," & lprcPosRect.Right & "," & lprcPosRect.Bottom
        
        
        #If LOG_USERCONTROL Then
            Log("IOleObject_DoVerb", iVerb, lpmsg, ObjPtr(pActiveSite), lindex, hwndParent, "Width", lprcPosRect.Right - lprcPosRect.Left, "Height", lprcPosRect.Bottom - lprcPosRect.Top)
        #End If
                    
        'Exit Sub '**********
        
        Debug.TracePrint "*** IOleObject_DoVerb 1"
        Dim site As Any = CType(Of IOleInPlaceSite)(InternalState.OleClientSite)
        ' If site Is Nothing Then
        '     Debug.Print IOleObject_SetClientSite_WasCalled
        '     Stop
        ' End If
        Debug.TracePrint "*** IOleObject_DoVerb 2"
                        
        Dim hwnd As HWND = InternalHWND()
        
        ' NOTE: OLEIVERB_PRIMARY on a VB6 user control shows the first property page
                    
        Dim isWindowVisible As Boolean = (hwnd.GetWindowLongW(GWL_STYLE) And WS_VISIBLE) <> 0
        
        Select Case iVerb
            Case OLEIVERB_HIDE
                
                If Me.Windowless = True Then
                    If InternalState.IsTbDebugging = False Then
                        On Error Resume Next
                    End If
                    RaiseEvent Hide()
                Else
                    If isWindowVisible = False Then Exit Sub
                    hwnd.ShowWindow(SW_HIDE)

                    If InternalState.ConsumerVisibilityState = True Then
                        If InternalBaseControlInfo.EventsAreFrozen = False Then
                            InternalState.ConsumerVisibilityState = False
                            If InternalState.IsTbDebugging = False Then
                                On Error Resume Next
                            End If
                            RaiseEvent Hide()
                        Else
                            InternalState.QueuedShowEvent = True
                        End If
                    End If
                End If
                                
        	Case OLEIVERB_SHOW, _               
                    OLEIVERB_INPLACEACTIVATE
                    
                Debug.TracePrint "*** IOleObject_DoVerb 3"
                
                If isWindowVisible = True Then Exit Sub
                
                ' In VB6 UserControl implementation, SHOW and UIACTIVATE appear identical.
                
                If InternalState.WindowIsInPlace = False Then
                
                    If Me.Windowless = True Then
                        On Error Resume Next
                        
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "testing for IOleInPlaceSiteWindowless suppport")
                        #End If
                        Dim siteWindowless As Any = CType(Of IOleInPlaceSiteWindowless)(InternalState.OleClientSite)
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "testing for IOleInPlaceSiteWindowless suppport... DONE")
                        #End If
                        
                        If siteWindowless Is Nothing Then
                            #If LOG_USERCONTROL Then
                                Log("IOleObject_DoVerb", "reverting to WindowedMode...")
                            #End If
                            GoTo WindowedMode
                        End If
                        
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling siteWindowless.CanWindowlessActivate")
                        #End If
                        siteWindowless.CanWindowlessActivate()
                        Dim activateResult As Long = Err.LastHresult
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "siteWindowless.CanWindowlessActivate... DONE.   Result: " & Hex(activateResult))
                        #End If
                        
                        If activateResult = S_FALSE Then
                            ' The container site doesn't support windowless, so proceed with normal windowed-mode
                            #If LOG_USERCONTROL Then
                                Log("IOleObject_DoVerb", "reverting to WindowedMode...(2)")
                            #End If
                            GoTo WindowedMode
                        End If
                        
                        On Error GoTo 0
                        
                        InternalState.IsWindowlessActivated = True
                        
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling siteWindowless.OnInPlaceActivateEx")
                        #End If
                        siteWindowless.OnInPlaceActivateEx(CLngPtr(0), 1)       ' ACTIVATE_WINDOWLESS
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling siteWindowless.OnInPlaceActivateEx... DONE")
                        #End If
                        ' site will typically query us for IOleInPlaceObjectWindowless at this point (optionally implemented)
                        
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling siteWindowless.GetWindow")
                        #End If
                        siteWindowless.GetWindow(parentWnd)
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling siteWindowless.GetWindow... DONE")
                        #End If

                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling siteWindowless.GetWindowContext")
                        #End If
                        siteWindowless.GetWindowContext(InternalState.siteFrame, InternalState.siteDoc, posRect, clipRect, FrameInfo)
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling siteWindowless.GetWindowContext... DONE")
                        #End If

                        ' VB6 does this...
                        Dim pDC As HDC
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling siteWindowless.GetDC")
                        #End If
                        siteWindowless.GetDC(ByVal vbNullPtr, 1, pDC)
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling siteWindowless.GetDC... DONE")
                        #End If
                        ' FIXME investigate what VB6 uses this for.  What API calls does it make here?

                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling siteWindowless.ReleaseDC")
                        #End If
                        siteWindowless.ReleaseDC(pDC)
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling siteWindowless.ReleaseDC... DONE")
                        #End If
                        
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling siteWindowless.InvalidateRect")
                        #End If
                        siteWindowless.InvalidateRect(ByVal vbNullPtr, 1)
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling siteWindowless.InvalidateRect... DONE")
                        #End If
                        
                        LSet InternalState.WindowlessRect = lprcPosRect
                        
                        ' the site should now call IViewObject.Draw() etc appropriately.
                        
                        If InternalState.IsTbDebugging = False Then
                            On Error Resume Next
                        End If
                        RaiseEvent Show()
                    Else

                    WindowedMode:
                        Debug.TracePrint "*** IOleObject_DoVerb 4"
                        Dim resizeToContainer As Boolean = If(iVerb = OLEIVERB_SHOW, True, False)
                    
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling site.CanInPlaceActivate")
                        #End If
                        site.CanInPlaceActivate()
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling site.CanInPlaceActivate... DONE")
                        #End If

                        Debug.TracePrint "*** IOleObject_DoVerb 5"
                        
                        If Err.LastHresult = S_FALSE Then
                            ' VB6 bombs out here too
                            Err.Raise 5, , "Container does not support in-place activation"
                        End If
                        
                        Debug.TracePrint "*** IOleObject_DoVerb 6"
                        
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling site.OnInPlaceActivate")
                        #End If
                        site.OnInPlaceActivate()
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling site.OnInPlaceActivate... DONE")
                        #End If
                        
                        Debug.TracePrint "*** IOleObject_DoVerb 7"
                        
                        Dim parentWnd As HWND
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling site.GetWindow")
                        #End If
                        site.GetWindow(parentWnd)
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling site.GetWindow... DONE")
                        #End If
                        Dim FrameInfo As OLEINPLACEFRAMEINFO
                        Dim posRect As tbRECT
                        Dim clipRect As tbRECT
                        
                        Debug.TracePrint "*** IOleObject_DoVerb 8"
                        
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling site.GetWindowContext")
                        #End If
                        site.GetWindowContext(InternalState.siteFrame, InternalState.siteDoc, posRect, clipRect, FrameInfo)
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling site.GetWindowContext... DONE")
                        #End If
                        
                        ' In VB6, hwndParent is authoratitive, ignoring FrameInfo.hwndFrame (though they are usually the same).
                        ' Only at this point does the window get attached to the real container via SetParent...
                        InternalState.ContainerWindow = hwndParent

                        Debug.TracePrint "*** IOleObject_DoVerb 9"
                        
                        ' For a NEWLY ADDED control (i.e. InitNew was called), VBx implementation also calls IViewObject_Draw around here (just before raising the UserControl Resize event).

                        ' VB6 seems to use IOleInPlaceObject_SetObjectRects here
                        SetObjectRects(posRect, clipRect)     ' this will call MoveWindow
                        'Debug.Print "DoVerb SetObjectRects"
                        
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling SetWindowPos... DONE", "Me.PixelsWidth(BEFORE)", Me.PixelsWidth, "Me.PixelsHeight(BEFORE)", Me.PixelsHeight)
                        #End If
                        'InternalSetWindowPos(Me.hWnd, 0, posRect.Left, posRect.Top, posRect.Right - posRect.Left, posRect.Bottom - posRect.Top, SWP_NOREDRAW Or SWP_NOOWNERZORDER Or SWP_NOACTIVATE Or SWP_NOZORDER)
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling SetWindowPos... DONE", "Me.PixelsWidth(AFTER)", Me.PixelsWidth, "Me.PixelsHeight(AFTER)", Me.PixelsHeight)
                        #End If
                        
                        
                        
                        
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling SetParent")
                        #End If
                        
                        'Debug.Print "DoVerb SetParent"
                        
                        Debug.TracePrint "*** IOleObject_DoVerb 11"
                        hwnd.SetParent(InternalState.ContainerWindow)
                        Debug.TracePrint "*** IOleObject_DoVerb 12"
                        
                        InternalState.HwndIsParented = True
                        
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling SetParent... DONE")
                        #End If
                        
                        
                        
                        
                        
                        ' FIXME Not sure why this is actually necessary, as it isn't in VB6.  In my notes, after SetParent(), it can lose the WS_CLIPSIBLINGS style
                        Dim styles As Long = hwnd.GetWindowLongW(WindowProperties.GWL_STYLE)
                        styles = styles And (Not WS_POPUP)
                        styles = styles Or WS_CHILD Or WS_CLIPSIBLINGS
                        hwnd.SetWindowLongW(WindowProperties.GWL_STYLE, styles)
                        
                        
                        'MsgBox "DoVerb.1"
                        InternalState.MutedResizeEventsCount += 1
                            #If LOG_USERCONTROL Then
                                Log("IOleObject_DoVerb", "calling ShowWindow")
                            #End If
                            'Debug.Print "DoVerb SetWindowPos"
                            
                            hwnd.SetWindowPos(HWND_BOTTOM, 0, 0, 0, 0, SWP_NOACTIVATE Or SWP_NOCOPYBITS Or SWP_NOREDRAW Or SWP_NOMOVE Or SWP_NOSIZE)
                            
                            
                            Dim HasFinishedLoading As Boolean = Me.InternalState.HasFinishedLoading
                            Me.InternalState.IgnorePropertyChangedNotifications += (HasFinishedLoading = False)
                            If InternalState.IsTbDebugging = False Then
                                On Error Resume Next
                            End If
                            'Debug.Print "DoVerb *** EVENT *** Resize"
                            If InternalState.IsInResizeEvent = False Then
                                InternalState.IsInResizeEvent = True
                                If InternalState.HasFinishedLoading Then
                                    InternalState.HasRaisedInitialResizeEvent = True
                                    RaiseEvent Resize()
                                End If
                                InternalState.IsInResizeEvent = False
                            End If
                            On Error GoTo 0
                            Me.InternalState.IgnorePropertyChangedNotifications -= (HasFinishedLoading = False)
                        
                            Debug.TracePrint "*** IOleObject_DoVerb 10"
                            
                            ' This message is used to defer raise event Show
                            RootWindowElementBase.RuntimeUIGetHandle().PostMessageW(WM_TB_INTERNAL_SELF_DEFERRED_MESSAGE, SELF_DEFFERED_SHOW, 0)
                            
                            hwnd.ShowWindow(SW_SHOWNA)
                            #If LOG_USERCONTROL Then
                                Log("IOleObject_DoVerb", "calling ShowWindow... DONE")
                            #End If
                            'IOleInPlaceObject_SetObjectRects(lprcPosRect, lprcPosRect)
                            InternalState.MutedResizeEventsCount -= 1
                            'MsgBox "DoVerb.2"
                             
                        Debug.TracePrint "*** IOleObject_DoVerb 13"
                        
                        If Me.ForceResizeToContainer And resizeToContainer Then
                            SynchronizeWindowSizeWithParent(hwnd, InternalState.ContainerWindow)
                            
                            Debug.TracePrint "*** IOleObject_DoVerb 13a"
                        End If
                    End If

                    InternalState.WindowIsInPlace = True
    
                Else
                    ' This message is used to defer raise event Show
                    RootWindowElementBase.RuntimeUIGetHandle().PostMessageW(WM_TB_INTERNAL_SELF_DEFERRED_MESSAGE, SELF_DEFFERED_SHOW, 0)
                    
                    hwnd.ShowWindow(SW_SHOWNA)
                End If

                #If LOG_USERCONTROL Then
                    Log("IOleObject_DoVerb", "OleClientSite.ShowObject()")
                #End If
                InternalState.OleClientSite.ShowObject() ' this is called AFTER the control is attached to the real parent above
                #If LOG_USERCONTROL Then
                    Log("IOleObject_DoVerb", "OleClientSite.ShowObject()... DONE")
                #End If
                
                ' If InternalState.ConsumerVisibilityState = False Then
                '     If InternalBaseControlInfo.EventsAreFrozen = False Then
                '         InternalState.ConsumerVisibilityState = True
                '         If InternalState.IsTbDebugging = False Then
                '             On Error Resume Next
                '         End If
                '         RaiseEvent Show()
                '     Else
                '         InternalState.QueuedShowEvent = True
                '     End If
                ' End If
                                
            Case OLEIVERB_UIACTIVATE
                
                If Me.Windowless = False Then
                    If RootWindowElementBase.RuntimeUIActivateAX() = 1 Then
                        ' No focusable child control, so focus the main hwnd
                        hwnd.SetFocus()        ' do this, else iGrid doesn't activate properly in VBA UserForms
                    End If
                End If
                #If LOG_USERCONTROL Then
                    Log("HandleEnterFocus -> site.OnUIActivate()")
                #End If
                site.OnUIActivate()
                #If LOG_USERCONTROL Then
                    Log("HandleEnterFocus -> site.OnUIActivate()... DONE")
                #End If
                If site IsNot Nothing Then
                    #If LOG_USERCONTROL Then
                        Log("HandleEnterFocus -> siteFrame.SetMenu(0, 0, 0)")
                    #End If
                    On Error Resume Next
                    InternalState.siteFrame.SetMenu(0, 0, 0)
                    On Error GoTo 0
                    #If LOG_USERCONTROL Then
                        Log("HandleEnterFocus -> siteFrame.SetMenu(0, 0, 0)... DONE")
                    #End If
                End If
                
            Const CUSTOM_OLEIVERB_1 As Long = 1
            Case OLEIVERB_PROPERTIES, CUSTOM_OLEIVERB_1
                ' MS Access uses this method for triggering opening of the property sheet
                Dim pagesInfo As CAUUID
                ISpecifyPropertyPagesGetPages(pagesInfo)       ' FIXME mem leak
                'MsgBox "Opening property pages: " & pagesInfo.cElems
                'MsgBox "OleCreatePropertyFrame"
                Dim ctrlName As String = "Custom"
                On Error Resume Next
                ctrlName = CStr(Me.Extender.Name)
                
                Dim SerializeInfo As SerializeInfo
                SerializeInfo.Pointer = GetClassInstanceSerializer([_HiddenModule].GetInheritedOwner(Me))
                Dim outerClass As Any = SerializeInfo.RuntimeUISrzGetRootClassDispatch()
                
                OLEAUT32.OleCreatePropertyFrame(hwndParent, 0, 0, ctrlName, 1, ObjPtr(outerClass), pagesInfo.cElems, pagesInfo.pElems, 0, 0, vbNullPtr)
                'MsgBox "OleCreatePropertyFrame [DONE]"
                'MsgBox Err.Description & "," & Hex(Err.Number)
                
            Case Is >= 2
                If (iVerb - 2) <= UBound(Verbs) Then
                    RaiseEvent VerbInvoked(Verbs(iVerb - 2))
                End If
        End Select
        
        #If LOG_USERCONTROL Then
            Log("IOleObject_DoVerb", iVerb, lpmsg, ObjPtr(pActiveSite), lindex, hwndParent, "Width", lprcPosRect.Right - lprcPosRect.Left, "Height", lprcPosRect.Bottom - lprcPosRect.Top, "... DONE")
        #End If
    End Sub

    Protected Sub RaiseShowEvent(ByVal wParam As LongPtr, ByVal lParam As LongPtr) _
            Implements IWindowElementEventsUC.DeferredUcMessage
        
        Select Case wParam
            Case SELF_DEFFERED_SHOW
                If InternalState.IsTbDebugging = False Then
                    On Error Resume Next
                End If
        
                'Debug.Print "RootWindowElementBase.DeferredUcShowEvent *** EVENT *** Show"
                RaiseEvent Show()
                
            Case SELF_DEFFERED_CLIP
                'LogRect("SELF_DEFFERED_CLIP.ClippedRect", InternalState.ClippedRect.Left, InternalState.ClippedRect.Top, InternalState.ClippedRect.Right, InternalState.ClippedRect.Bottom)
                
                Dim clippedRgn As Any = GDI32.CreateRectRgnIndirect(InternalState.ClippedRect)
                RootWindowElementBase.RuntimeUIGetHandle().SetWindowRgn(clippedRgn, 1)
                InternalState.WindowRgnIsClipped = True
        End Select
    End Sub
    
    Protected Sub IOleObjectUpdate() _
            Implements IOleObject.Update
        #If LOG_USERCONTROL Then
            Log("IOleObject_Update")
        #End If
        ' Correct implementation
    End Sub
    
    Protected Sub IOleObjectIsUpToDate() _
            Implements IOleObject.IsUpToDate
        #If LOG_USERCONTROL Then
            Log("IOleObject_IsUpToDate")
        #End If
        ' Correct implementation
    End Sub

    Protected Sub IOleObjectGetUserClassID(ByVal pClsid As LongPtr) _
            Implements IOleObject.GetUserClassID
        #If LOG_USERCONTROL Then
            Log("IOleObject_GetUserClassID", "{RootCLSID: " & GetRootCLSIDStr() & "}")
        #End If
        OLE32.IIDFromString(GetRootCLSIDStr(), pClsid)
    End Sub

    Private InternalIgnoreSetExtent As Boolean
    Protected Sub IOleObjectSetExtent(ByVal dwDrawAspect As Long, ByRef psizel As SIZEL) _
            Implements IOleObject.SetExtent
        If InternalIgnoreSetExtent = True Then
            Debug.TracePrint "IOleObjectSetExtent -> InternalIgnoreSetExtent=TRUE"
            Err.ReturnHResult = &H8000FFFF
            Exit Sub
        End If

        #If LOG_USERCONTROL Then
            Log("IOleObject_SetExtent *", dwDrawAspect, psizel.cx, psizel.cy)
        #End If
        
        'Debug.Print "UserControl IOleObject_SetExtent"
        
        'MsgBox "SetExtent: " & InternalState.[_ExtentX]
        InternalState.[_ExtentX] = psizel.cx
        InternalState.[_ExtentY] = psizel.cy
        
        InternalState.WindowlessRect.Right = InternalState.WindowlessRect.Left + psizel.cx
        InternalState.WindowlessRect.Bottom = InternalState.WindowlessRect.Top + psizel.cy
            
        Dim hWnd As HWND
        hWnd = Me.RootWindowElementBase.RuntimeUIGetHandle()
        
        If hWnd.Value <> 0 Then
            ' FIXME need to check if this is what really happens.  Currently not hit during initialization
           ' Stop
        	Dim RootWindowElementBase As Any = Me.RootWindowElementBase
            'Dim current_cx As Double = Me.RootWindowElementBase.ScaleX(Me.PixelsWidth, vbScaledPixels, vbHimetric)
            'Dim current_cy As Double = Me.RootWindowElementBase.ScaleY(Me.PixelsHeight, vbScaledPixels, vbHimetric)

            Dim rect As tbRECT
            hWnd.GetWindowRect(rect)
            Dim current_cx As Long = CLng(RootWindowElementBase.RuntimeUIScaleX(rect.Right - rect.Left, vbPixels, vbHimetric))
            Dim current_cy As Long = CLng(RootWindowElementBase.RuntimeUIScaleY(rect.Bottom - rect.Top, vbPixels, vbHimetric))
            
            If (current_cx = psizel.cx) And (current_cy = psizel.cy) Then
                ' No change
                Exit Sub
            End If

            Dim cx As Double = RootWindowElementBase.RuntimeUIScaleX(psizel.cx, vbHimetric, vbPixels)
            Dim cy As Double = RootWindowElementBase.RuntimeUIScaleY(psizel.cy, vbHimetric, vbPixels)
            
            hWnd.SetWindowPos(0, 0, 0, CLng(cx), CLng(cy), SWP_NOMOVE Or SWP_NOREDRAW Or SWP_NOOWNERZORDER Or SWP_NOACTIVATE Or SWP_NOZORDER)
            'InternalSetWindowPos(Me.hWnd, 0, 0, 0, CLng(cx), CLng(cy), SWP_NOMOVE Or SWP_NOACTIVATE Or SWP_NOZORDER)
            
            ' This makes auto-resize of VBCCR MonthView work at design time by decoupling the resize event from SetExtent() which is protected against re-entrancy
            ' FIXME if we always use ScheduleCallback for this, then we get an endless loop of SetExtent being called at runtime
            ' clearly, this is not quite right.
            If Ambient.UserMode = False Then
                Me.ScheduleCallbackResize = True
                If InternalState.IsInResizeCallback = False Then        ' prevent endless loop opening fLems.frm
                    ControlContext.RuntimeUICtxScheduleCallback(Me)
                End If
            Else
                Dim HasFinishedLoading As Boolean = Me.InternalState.HasFinishedLoading
                Me.InternalState.IgnorePropertyChangedNotifications += (HasFinishedLoading = False)
                If InternalState.IsTbDebugging = False Then
                    On Error Resume Next
                End If
                If MutedSetExtentResize = False Then
                    If InternalState.IsInResizeEvent = False Then
                        InternalState.IsInResizeEvent = True
                        If InternalState.HasFinishedLoading Then
                            InternalState.HasRaisedInitialResizeEvent = True
                            RaiseEvent Resize()
                        End If
                        InternalState.IsInResizeEvent = False
                    End If
                End If
                Me.InternalState.IgnorePropertyChangedNotifications -= (HasFinishedLoading = False)
            End If
        End If
        
        ' VBx does IViewObject_Draw here
        
        On Error Resume Next
        Dim OleClientSite As Any = Me.InternalState.OleClientSite
        If OleClientSite IsNot Nothing Then OleClientSite.RequestNewObjectLayout()  ' RequestNewObjectLayout can fail in MSACCESS
        
        If MutedSetExtentResize = False Then
            InternalState.PropertiesChanged = True
        End If
    End Sub
    
    Protected Sub IOleObjectGetExtent(ByVal dwDrawAspect As Long, ByRef psizel As SIZEL) _
            Implements IOleObject.GetExtent
        #If LOG_USERCONTROL Then
            Log("IOleObject_GetExtent *", dwDrawAspect, "Me.PixelsWidth", Me.PixelsWidth, "Me.PixelsHeight", Me.PixelsHeight)
        #End If
        
        psizel.cx = CLng(InternalState.[_ExtentX])
        psizel.cy = CLng(InternalState.[_ExtentY])
        
        Debug.TracePrint "IOleObject_GetExtent -> (" & psizel.cx & ", " & psizel.cy & ")"
            
        ' If IsWindowlessActivated Then
        '     psizel.cx = WindowlessRect.Right - WindowlessRect.Left
        '     psizel.cy = WindowlessRect.Bottom - WindowlessRect.Top
        ' Else
        '     ' Get the real HWND pixel width/height
        '     'psizel.cx = Me.RootWindowElementBase.ScaleX(Me.PixelsWidth, vbScaledPixels, vbHimetric)         doesn't include borders
        '     'psizel.cy = Me.RootWindowElementBase.ScaleY(Me.PixelsHeight, vbScaledPixels, vbHimetric)
            
            
            
        '     ' Dim RootWindowElementBase As Any = Me.RootWindowElementBase
        '     ' Dim rect As tbRECT
        '     ' GetWindowRect(Me.hWnd, rect)
        '     ' Debug.TracePrint "*** GetExtent RESULT HEIGHT: " & (rect.Bottom - rect.Top)
        '     ' psizel.cx = RootWindowElementBase.ScaleX(rect.Right - rect.Left, vbPixels, vbHimetric)
        '     ' psizel.cy = RootWindowElementBase.ScaleY(rect.Bottom - rect.Top, vbPixels, vbHimetric)

        '     ' Static OrigWidth As Long = 0
        '     ' If OrigWidth = 0 Then
        '     ' OrigWidth = psizel.cx
        '     ' Else
        '     '     psizel.cx = _ExtentX
        '     ' End If
            
        '     ' Static OrigHeight As Long = 0
        '     ' If OrigHeight = 0 Then
        '     '     OrigHeight = psizel.cy
        '     ' Else
        '     '     psizel.cy = OrigHeight
        '     ' End If
        ' End If
        
        #If LOG_USERCONTROL Then
            Log("IOleObject_GetExtent", dwDrawAspect, "result: (" & psizel.cx & "x" & psizel.cy & ")")
        #End If
    End Sub

    Protected Sub IOleObjectGetUserType(ByVal dwFormOfType As Long, ByVal pszUserType As LongPtr) _
            Implements IOleObject.GetUserType
        #If LOG_USERCONTROL Then
            Log("IOleObject_GetUserType", dwFormOfType, pszUserType)
        #End If
            
        Dim temp As GUID2
        OLE32.IIDFromString(GetRootCLSIDStr(), VarPtr(temp))
        OLE32.OleRegGetUserType(VarPtr(temp), dwFormOfType, pszUserType)
        
        #If LOG_USERCONTROL Then
            Log("IOleObject_GetUserType (HRESULT): " & Hex(hr))
        #End If
    End Sub
        
    Protected Sub IOleObjectAdvise(ByVal pAdvSink As VBRUN.tbInternal_IAdviseSink, pdwConnection As Long) _
            Implements IOleObject.Advise
        #If LOG_USERCONTROL Then
            Log("IOleObject_Advise", ObjPtr(pAdvSink), pdwConnection)
        #End If
        ' FIXME would need to maintain an array of connections here
        'Set IOleObject_adviseSink = pAdvSink
        'pdwConnection = 1
        
        ' FIXME look into CreateOleAdviseHolder
    End Sub
    
    Protected Sub IOleObjectUnadvise(ByVal dwConnection As Long) _
            Implements IOleObject.Unadvise
        #If LOG_USERCONTROL Then
            Log("IOleObject_Unadvise", dwConnection)
        #End If
        'Set IOleObject_adviseSink = Nothing
    End Sub
    
    Protected Sub IOleObjectEnumAdvise(ByRef ppenumAdvise As VBRUN.tbInternal_IEnumSTATDATA) _
            Implements IOleObject.EnumAdvise
        #If LOG_USERCONTROL Then
            Log("IOleObject_EnumAdvise", ObjPtr(ppenumAdvise))
        #End If
        Err.ReturnHResult = E_NOTIMPL
        ' FIXME this can be directed to a method on the object returned from CreateOleAdviseHolder
    End Sub
    
    Protected Sub IOleObjectGetMiscStatus(ByVal dwAspect As Long, ByRef pdwStatus As Long) _
            Implements IOleObject.GetMiscStatus
        GetClasInstanceAxMiscFlags([_HiddenModule].GetInheritedOwner(Me), pdwStatus)
        Debug.TracePrint "--> out misc flags " & Hex(pdwStatus)
        'Debug.TracePrint "RefCount: " & GetClassInstanceRefCount(Me)
    End Sub
    
    Protected Sub IOleObjectSetColorScheme(ByVal pLogpal As LongPtr) _
            Implements IOleObject.SetColorScheme
        #If LOG_USERCONTROL Then
            Log("IOleObject_SetColorScheme", pLogpal)
        #End If
        Err.ReturnHResult = E_NOTIMPL                ' Correct implementation
    End Sub
    
    Protected Sub IPersistGetClassID(pClassID As GUID) _
            Implements IPersist.GetClassID, _
                        IPersistStreamInit.GetClassID, _
                        IPersistStorage.GetClassID, _
                        IPersistPropertyBag.GetClassID

        #If LOG_USERCONTROL Then
            Log("IPersistStream_GetClassID")
        #End If
        OLE32.IIDFromString(GetRootCLSIDStr(), VarPtr(pClassID))
    End Sub

    Protected Sub IPersistStreamIsDirty() _
            Implements IPersistStreamInit.IsDirty, _
                        IPersistStorage.IsDirty
        #If LOG_USERCONTROL Then
            Log("IPersistStream_IsDirty")
        #End If
        ' FIXME Access doesn't save for just changes of the control size if we do this
        If InternalState.PropertiesChanged = False Then
             Err.ReturnHResult = S_FALSE
        End If
        'MsgBox "IsDirty HRESULT: " & Err.ReturnHResult
        
        
        
        'Err.ReturnHResult = S_FALSE
    End Sub
    
    Protected Sub ReadPropertiesFromPropBag(propBag As PropertyBag)
        On Error Resume Next
        
        #If LOG_USERCONTROL Then
            Log("ReadPropertiesFromPropBag (1)")
        #End If
        ' Before firing ReadProperties, we need to set the correct size of the control
        ' this will also fire the Resize event, which is expected here, as per VBx
        
        InternalState.[_ExtentX] = CLng(propBag.ReadProperty("_ExtentX", -1))     ' in twips
        InternalState.[_ExtentY] = CLng(propBag.ReadProperty("_ExtentY", -1))     ' in twips
        
        'Debug.Print "ReadPropertiesFromPropBag InternalState.[_ExtentX]:=", InternalState.[_ExtentX]
        'Debug.Print "ReadPropertiesFromPropBag InternalState.[_ExtentY]:=", InternalState.[_ExtentY]
        
        'Debug.TracePrint "ReadPropertiesFromPropBag (2)", "_ExtentX:", InternalState.[_ExtentX], "_ExtentY", InternalState.[_ExtentY]
        
        #If LOG_USERCONTROL Then
            Log("ReadPropertiesFromPropBag (2)", "_ExtentX:", _ExtentX, "_ExtentY", _ExtentY)
        #End If
        If (InternalState.[_ExtentX] = -1) Or (InternalState.[_ExtentY] = -1) Then
        	' Previously, tB serialization didn't include the _ExtentX/_ExtentY values, so we have to get them from the
            '  tb extender instead.  The alternative below is not host-agnostic, but works for our older serializations.
            
            'Debug.Print "UserControl InitializeMe"
            InitializeMe    ' this should cause creation of the HWND etc
            
            'Debug.TracePrint "ReadPropertiesFromPropBag (2a)"
            
            Dim inPlaceSite As Any = CType(Of IOleInPlaceSite)(Me.InternalState.OleClientSite)
            'Debug.TracePrint "ReadPropertiesFromPropBag (2a.0) ", ObjPtr(inPlaceSite)
            
            Dim posRect As tbRECT
            Dim clipRect As tbRECT
            Dim frameInfoIgnored As OLEINPLACEFRAMEINFO
            inPlaceSite.GetWindowContext(Nothing, Nothing, posRect, clipRect, frameInfoIgnored)            ' if we don't provide frameInfo, Excel TaskPane crashes here
            'Debug.TracePrint "ReadPropertiesFromPropBag (2a.1) ", posRect.Left
            Me.InternalHWND.SetWindowPos(0, 0, 0, posRect.Right - posRect.Left, posRect.Bottom - posRect.Top, SWP_NOMOVE Or SWP_NOREDRAW Or SWP_NOOWNERZORDER Or SWP_NOACTIVATE Or SWP_NOZORDER)
            InternalState.[_ExtentX] = RootWindowElementBase.RuntimeUIScaleX(posRect.Right - posRect.Left, vbPixels, vbTwips)
            InternalState.[_ExtentY] = RootWindowElementBase.RuntimeUIScaleY(posRect.Bottom - posRect.Top, vbPixels, vbTwips)
            'Debug.TracePrint "ReadPropertiesFromPropBag (2b)"
        Else

            'InternalChangeSizeNoEvents(Me, Me.RootWindowElementBase.ScaleX(_ExtentX, vbTwips, vbScaledPixels), Me.RootWindowElementBase.ScaleY(_ExtentY, vbTwips, vbScaledPixels))
            Dim newPixelWidth As Long
            Dim newPixelHeight As Long
            
            ' If Me.Windowless = True Then
            ' 	Stop
            ' Else
            '    newPixelWidth = Me.RootWindowElementBase.ScaleX(_ExtentX, vbTwips, vbPixels)
            '    newPixelHeight = Me.RootWindowElementBase.ScaleY(_ExtentY, vbTwips, vbPixels)
            'End If

            Dim Size As SIZEL
            Size.cx = CLng(InternalState.[_ExtentX])
            Size.cy = CLng(InternalState.[_ExtentY])
            
            'MsgBox "_ExtentX: " & Size.cx
            MutedSetExtentResize = True             ' Resize not called before ReadProperties!!
            IOleObjectSetExtent(1, Size)       ' causes IOleClientSite_RequestNewObjectLayout to be called
            MutedSetExtentResize = False
                        
            #If LOG_USERCONTROL Then
                Log("ReadPropertiesFromPropBag (2a)", "calling SetWindowPos", "newPixelWidth", newPixelWidth, "newPixelHeight", newPixelHeight)
            #End If
            
            'Debug.Print "UserControl InitializeMe"
            InitializeMe    ' this should cause creation of the HWND etc
            'Debug.TracePrint "ReadPropertiesFromPropBag (2c)"
            
            ' These will now be DPI aware... (but not necessarily correct DPI as we're not parented by the final host yet, just our STATIC HWND parent)
            newPixelWidth = CLng(RootWindowElementBase.RuntimeUIScaleX(InternalState.[_ExtentX], vbHimetric, vbPixels))
            newPixelHeight = CLng(RootWindowElementBase.RuntimeUIScaleY(InternalState.[_ExtentY], vbHimetric, vbPixels))
            'Debug.TracePrint "ReadPropertiesFromPropBag (2a)", "calling SetWindowPos", "newPixelWidth", newPixelWidth, "newPixelHeight", newPixelHeight
            'Debug.Print "UserControl ReadPropertiesFromPropBag SetWindowPos(" & newPixelWidth & "," & newPixelHeight & ")"
            Me.InternalHWND.SetWindowPos(0, 0, 0, newPixelWidth, newPixelHeight, SWP_NOMOVE Or SWP_NOACTIVATE Or SWP_NOZORDER)
            
            'Debug.TracePrint "ReadPropertiesFromPropBag (2d)"
            
            ' this is to fix any minor discrepency due to floating point scaling
            'Me.ScaleWidth = Me.RootWindowElementBase.ScaleX(_ExtentX, vbTwips, Me.ScaleMode)
            'Me.ScaleHeight = Me.RootWindowElementBase.ScaleY(_ExtentY, vbTwips, Me.ScaleMode)
        End If
                
    
        'Debug.TracePrint "ReadPropertiesFromPropBag (2e)"
        
        #If LOG_USERCONTROL Then
            Log("ReadPropertiesFromPropBag (3)")
        #End If
        Me.InternalState.IgnorePropertyChangedNotifications += 1
        If InternalState.IsTbDebugging = False Then
            On Error Resume Next
        End If
        'Debug.Print "UserControl ReadPropertiesFromPropBag *** EVENT *** ReadProperties"
        
        RaiseEvent ReadProperties(propBag)      ' This THROWS in the MSACCESS version?
        Me.InternalState.IgnorePropertyChangedNotifications -= 1
        
        InternalState.HasFinishedLoading = True
        #If LOG_USERCONTROL Then
            Log("ReadPropertiesFromPropBag (4)")
        #End If
    End Sub
    
    Protected Sub IPersistPropertyBagLoad(ByVal pPropBag As IPropertyBag, ByVal pErrorLog As stdole.IUnknown) _
            Implements IPersistPropertyBag.Load
        'Debug.Print "UserControl IPersistPropertyBag_Load"
        #If LOG_USERCONTROL Then
            Log("IPersistPropertyBag_Load")
        #End If
        'If InternalState.IsInitialized = False Then InitializeMe
        ReadPropertiesFromPropBag(CType(Of PropertyBag)([_HiddenModule].CreateClassPropertyBagUCRead2(pPropBag)))
    End Sub
    Protected Sub IPersistPropertyBagSave(ByVal pPropBag As IPropertyBag, ByVal fClearDirty As Long, ByVal fSaveAllProperties As Long) _
            Implements IPersistPropertyBag.Save
        #If LOG_USERCONTROL Then
            Log("IPersistPropertyBag_Save")
        #End If
        
        'Stop
        Dim propBag As Any = CType(Of PropertyBag)([_HiddenModule].CreateClassPropertyBagUCWrite2(pPropBag))
        #If LOG_USERCONTROL Then
            Log("IPersistPropertyBag_Save(1)")
        #End If
        
        ' FIXME does _ExtentX/Y get set BEFORE or AFTER in the VB6 implementation
        If InternalState.IsTbDebugging = False Then
            On Error Resume Next
        End If
        RaiseEvent WriteProperties(propBag)
        
        'Dim twipsWidth As Double = Me.RootWindowElementBase.ScaleX(Me.ScaleWidth, Me.ScaleMode, vbTwips)
        'Dim twipsHeight As Double = Me.RootWindowElementBase.ScaleY(Me.ScaleHeight, Me.ScaleMode, vbTwips)
        'Log("IPersistPropertyBag_Save (2)", "Me.ScaleWidth", Me.ScaleWidth, "Me.ScaleHeight", Me.ScaleHeight, "_ExtentX:", twipsWidth, "_ExtentY", twipsHeight)

        ' Dim twipsWidth As Long
        ' Dim twipsHeight As Long
        ' Dim RootWindowElementBase As Any = Me.RootWindowElementBase
'         If Me.hWnd <> 0 Then
'             Dim rect As tbRECT
'             GetWindowRect(Me.hWnd, rect)
'             twipsWidth = RootWindowElementBase.ScaleX(rect.Right - rect.Left, vbPixels, vbHimetric)
'             twipsHeight = RootWindowElementBase.ScaleY(rect.Bottom - rect.Top, vbPixels, vbHimetric)
'         Else
'         	twipsWidth = RootWindowElementBase.ScaleX(Me.ScaleWidth, Me.ScaleMode, vbHimetric)
'             twipsHeight = RootWindowElementBase.ScaleY(Me.ScaleHeight, Me.ScaleMode, vbHimetric)
'         End If
' '        Stop
'         propBag.WriteProperty("_ExtentX", twipsWidth)
'         propBag.WriteProperty("_ExtentY", twipsHeight)
        
        propBag.WriteProperty("_ExtentX", InternalState.[_ExtentX])
        propBag.WriteProperty("_ExtentY", InternalState.[_ExtentY])
                
        If fClearDirty Then
            InternalState.PropertiesChanged = False
        End If
    End Sub
    
    Protected Sub IPersistStreamLoad(ByVal pstm As IStream) _
            Implements IPersistStreamInit.Load
        'Debug.Print "UserControl IPersistStream_Load"
        #If LOG_USERCONTROL Then
            Log("IPersistStream_Load")
        #End If
        
        On Error GoTo StreamError
        'Dim A As String = "IPersistStream_Load"
        
        'If InternalState.IsInitialized = False Then InitializeMe
        
        #If LOG_USERCONTROL Then
            Log("IPersistStream_Load", ObjPtr(pstm))
        #End If
        
        'Dim styles As Long = GetWindowLongW(hWnd, WindowProperties.GWL_STYLE)
        #If LOG_USERCONTROL Then
            Log("IPersistStream_Load (BEFORE)", "hWnd: ", Hex(hWnd), "oldStyles: ", Hex(styles))
        #End If
        

        Dim streamStats As STATSTG
        pstm.Stat streamStats, STATFLAG_NONAME
                
        Dim currentPosition As LongLong
        pstm.Seek 0, STREAM_SEEK_CUR, currentPosition

        Dim loadData() As Byte
        'Dim propBag As PropertyBag
        
        Const magicIdSize As Long = 4
        If streamStats.cbSize >= (currentPosition + magicIdSize) Then
            Dim loadDataLen As Long = CLng(streamStats.cbSize - currentPosition - magicIdSize)
            #If LOG_USERCONTROL Then
                Log("IPersistStream_Load", ObjPtr(pstm), "SIZE:", loadDataLen)
            #End If
            
            ' FIXME We use a magic ID header, as we haven't yet checked whether VB6 adds anything 
            '   to the persisted stream other than the property bag data
            Dim magicId As Long
            Dim readAmount As Long
            pstm.Read(VarPtr(magicId), magicIdSize, readAmount)

            If (readAmount = magicIdSize) And (magicId = &HEAEAEAEA) Then
                ReDim loadData(loadDataLen) As Byte

                #If LOG_USERCONTROL Then
                    Log("IPersistStream_Load", ObjPtr(pstm), "SIZE:", loadDataLen, "... READING")
                #End If
                
                readAmount = 0
                pstm.Read(VarPtr(loadData(0)), loadDataLen, readAmount)
                
                If readAmount = loadDataLen Then
                    ReadPropertiesFromPropBag(CType(Of PropertyBag)([_HiddenModule].CreateClassPropertyBagUCRead(loadData)))
                End If
                
                #If LOG_USERCONTROL Then
                    Log("IPersistStream_Load", ObjPtr(pstm), "SIZE:", loadDataLen, "... DONE")
                #End If
            Else
                #If LOG_USERCONTROL Then
                    Log("IPersistStream_Load", ObjPtr(pstm), "BAD OLE STREAM (MAGIC ID) FOR " & Me.Ambient.DisplayName & ", PERSISTED DATA LOST")
                #End If
                Debug.Print "BAD OLE STREAM (MAGIC ID) FOR " & Me.Ambient.DisplayName & ", PERSISTED DATA LOST"
                If InternalState.IsTbDebugging = False Then
                    On Error Resume Next
                End If
                RaiseEvent InitProperties()
                Me.InternalHWND.SetWindowPos(0, 0, 0, 50, 50, SWP_NOMOVE Or SWP_NOREDRAW Or SWP_NOOWNERZORDER Or SWP_NOACTIVATE Or SWP_NOZORDER)
            End If
        Else
            #If LOG_USERCONTROL Then
                Log("IPersistStream_Load", ObjPtr(pstm), "BAD OLE STREAM FOR " & Me.Ambient.DisplayName & ", PERSISTED DATA LOST")
            #End If
            Debug.Print "BAD OLE STREAM FOR " & Me.Ambient.DisplayName & ", PERSISTED DATA LOST"

            If InternalState.IsTbDebugging = False Then
                On Error Resume Next
            End If
            RaiseEvent InitProperties()
            Me.InternalHWND.SetWindowPos(0, 0, 0, 50, 50, SWP_NOMOVE Or SWP_NOREDRAW Or SWP_NOOWNERZORDER Or SWP_NOACTIVATE Or SWP_NOZORDER)
        End If
        
        On Error Resume Next
        Dim OleClientSite As Any = Me.InternalState.OleClientSite
        If OleClientSite IsNot Nothing Then OleClientSite.RequestNewObjectLayout()
        
        InternalState.HasFinishedLoading = True
        Exit Sub
        
    StreamError:
        #If LOG_USERCONTROL Then
            Log("IPersistStream_Load", ObjPtr(pstm), "ERROR:", Err.Number, Err.Description)
        #End If
        Err.Raise 5
        
    End Sub
    
    Protected Sub IPersistStreamSave(ByVal pstm As IStream, ByVal fClearDirty As Long) _
            Implements IPersistStreamInit.Save
        #If LOG_USERCONTROL Then
            Log("IPersistStream_Save", ObjPtr(pstm), fClearDirty)
        #End If
        
        'MsgBox "Save"
        Dim propBag As Any = CType(Of PropertyBag)([_HiddenModule].CreateClassPropertyBagUCWrite())

        ' FIXME does _ExtentX/Y get set BEFORE or AFTER in the VB6 implementation
        
        If InternalState.IsTbDebugging = False Then
            On Error Resume Next
        End If
        RaiseEvent WriteProperties(propBag)
        
        'Dim twipsWidth As Double = Me.RootWindowElementBase.ScaleX(Me.ScaleWidth, Me.ScaleMode, vbTwips)
        'Dim twipsHeight As Double = Me.RootWindowElementBase.ScaleY(Me.ScaleHeight, Me.ScaleMode, vbTwips)
        
        Dim twipsWidth As Long
        Dim twipsHeight As Long
        Dim RootWindowElementBase As Any = Me.RootWindowElementBase
        If Me.InternalHWND.Value <> 0 Then
            Dim rect As tbRECT
            Me.InternalHWND.GetWindowRect(rect)
            twipsWidth = CLng(RootWindowElementBase.RuntimeUIScaleX(rect.Right - rect.Left, vbPixels, vbHimetric))
            twipsHeight = CLng(RootWindowElementBase.RuntimeUIScaleY(rect.Bottom - rect.Top, vbPixels, vbHimetric))
        Else
            twipsWidth = CLng(RootWindowElementBase.RuntimeUIScaleX(Me.ScaleWidth, Me.ScaleMode, vbHimetric))
            twipsHeight = CLng(RootWindowElementBase.RuntimeUIScaleY(Me.ScaleHeight, Me.ScaleMode, vbHimetric))
        End If
        
        propBag.WriteProperty("_ExtentX", twipsWidth)
        propBag.WriteProperty("_ExtentY", twipsHeight)
       
        #If LOG_USERCONTROL Then
            Log("IPersistStream_Save (2)", "Me.ScaleWidth", Me.ScaleWidth, "Me.ScaleHeight", Me.ScaleHeight, "_ExtentX:", twipsWidth, "_ExtentY", twipsHeight)
        #End If
        
        Dim contentsArray() As Byte
        ' propBag.Contents is artificially restricted, as per the VB6 implementation, so we have to access it differently...
        contentsArray = [_HiddenModule].GetPropertyBagUCWriterContents(propBag)
        
        Dim contentsLength As Long = (UBound(contentsArray) - LBound(contentsArray)) + 1
        #If LOG_USERCONTROL Then
            Log("IPersistStream_Save", "UBOUND: ", UBound(contentsArray), "LBOUND: ", LBound(contentsArray))
            Log("IPersistStream_Save", "LENGTH: ", contentsLength)
        #End If
        
        If contentsLength > 0 Then
            Dim written As Long
            Const magicIdSize As Long = 4
            Dim magicId As Long = &HEAEAEAEA
            pstm.Write(VarPtr(magicId), magicIdSize, written)

            If written <> magicIdSize Then
                Err.Raise 5
            End If

            written = 0
            pstm.Write(VarPtr(contentsArray(0)), contentsLength, written)
        
            If written <> contentsLength Then
                Err.Raise 5
            End If
        End If
        
        If fClearDirty Then
            InternalState.PropertiesChanged = False
        End If
    End Sub
    
    Protected Sub GetSizeMax(pcbSize As LongLong) _
            Implements IPersistStreamInit.GetSizeMax
        #If LOG_USERCONTROL Then
            Log("IPersistStream_GetSizeMax")
        #End If
        Err.ReturnHResult = E_NOTIMPL
    End Sub

    Protected Sub InitNew() _
            Implements IPersistStreamInit.InitNew, _
                        IPersistPropertyBag.InitNew
        #If LOG_USERCONTROL Then
            Log("IPersistStreamInit_InitNew")
        #End If
        If InternalState.IsInitialized = False Then InitializeMe
        #If LOG_USERCONTROL Then
            Log("IPersistStreamInit_InitNew... DONE")
        #End If
        
        If InternalState.IsTbDebugging = False Then
            On Error Resume Next
        End If
    
        Size(Me.ScaleX(CSng(Me.PixelsWidth), vbScaledPixels, vbTwips), Me.ScaleY(CSng(Me.PixelsHeight), vbScaledPixels, vbTwips))
        'Size(10, 10)
        
        RaiseEvent InitProperties()
        InternalState.HasFinishedLoading = True

        HandleInitialNewControlSize()
    End Sub
    
    Protected Sub HandleInitialNewControlSize()
        InternalState.HasRaisedInitialResizeEvent = True
        InternalState.IsSettingInitialSize = True
        On Error Resume Next
        RaiseEvent Resize()
        If InternalState.ChangedSizeDuringInitialResizeEvent Then
            Size(Me.ScaleX(CSng(Me.PixelsWidth), vbScaledPixels, vbTwips), Me.ScaleY(CSng(Me.PixelsHeight), vbScaledPixels, vbTwips))
        End If
        InternalState.IsSettingInitialSize = False
        
'        Dim IViewObject_adviseSink As Any = Me.InternalState.IViewObject_adviseSink
'        IViewObject_adviseSink.OnViewChange(DVASPECT_CONTENT, -1)
    End Sub
    
    Protected Sub IOleControlGetControlInfo(pCI As CONTROLINFO) _
            Implements IOleControl.GetControlInfo
        #If LOG_USERCONTROL Then
            Log("IOleControl_GetControlInfo")
        #End If
        ' FIXME need to implement this properly        
        pCI.cb = LenB(pCI)
        pCI.cAccel = 0
        pCI.dwFlags = 0
        pCI.hAccel = 0
    End Sub
    
    Protected Sub IOleControlOnMnemonic(pMsg As MSG) _
            Implements IOleControl.OnMnemonic
        #If LOG_USERCONTROL Then
            Log("IOleControl_OnMnemonic")
        #End If
        
        If pMsg.message = WM_KEYDOWN Then
            ' We only support the Cancel/Default values for now.
            If (pMsg.wParam = vbKeyEscape) Or (pMsg.wParam = vbKeyReturn) Or (pMsg.wParam = vbKeyExecute) Then
                Dim asciiKey As Integer = CInt(pMsg.wParam)
                RaiseEvent AccessKeyPress(asciiKey)
            End If
        End If
        ' FIXME need to implement this
        'Err.ReturnHResult = E_NOTIMPL
    End Sub
    
    Protected Sub IOleControlOnAmbientPropertyChange(ByVal dispID As Long) _
            Implements IOleControl.OnAmbientPropertyChange
        #If LOG_USERCONTROL Then
            Log("IOleControl_OnAmbientPropertyChange", dispID)
        #End If
        Dim namedProp As String
        Select Case dispID
        	Case DISPID_AMBIENT_BACKCOLOR: namedProp = "BackColor"
        	Case DISPID_AMBIENT_DISPLAYNAME: namedProp = "DisplayName"
        	Case DISPID_AMBIENT_FONT: namedProp = "Font"
        	Case DISPID_AMBIENT_FORECOLOR: namedProp = "ForeColor"
        	Case DISPID_AMBIENT_LOCALEID: namedProp = "LocaleID"
        	Case DISPID_AMBIENT_MESSAGEREFLECT: namedProp = "MessageReflect"
        	Case DISPID_AMBIENT_SCALEUNITS: namedProp = "ScaleUnits"
        	Case DISPID_AMBIENT_TEXTALIGN: namedProp = "TextAlign"
        	Case DISPID_AMBIENT_USERMODE: namedProp = "UserMode"
        	Case DISPID_AMBIENT_UIDEAD: namedProp = "UIDead"
        	Case DISPID_AMBIENT_SHOWGRABHANDLES: namedProp = "ShowGrabHandles"
        	Case DISPID_AMBIENT_SHOWHATCHING: namedProp = "ShowHatching"
        	Case DISPID_AMBIENT_DISPLAYASDEFAULT: namedProp = "DisplayAsDefault"
        	Case DISPID_AMBIENT_SUPPORTSMNEMONICS: namedProp = "SupportsMnemonics"
        	'Case DISPID_AMBIENT_AUTOCLIP: namedProp = "AutoClip"
        	'Case DISPID_AMBIENT_APPEARANCE: namedProp = "Appearance"
        	'Case DISPID_AMBIENT_CODEPAGE: namedProp = "CodePage"
        	Case DISPID_AMBIENT_PALETTE: namedProp = "Palette"
        	'Case DISPID_AMBIENT_CHARSET: namedProp = "Charset"
        	'Case DISPID_AMBIENT_TRANSFERPRIORITY: namedProp = "TransferPriority"
        	Case DISPID_AMBIENT_RIGHTTOLEFT: namedProp = "RightToLeft"
        	'Case DISPID_AMBIENT_TOPTOBOTTOM: namedProp = "TopToBottom"
        End Select
        If Len(namedProp) > 0 Then
            If InternalState.IsTbDebugging = False Then
                On Error Resume Next
            End If
            RaiseEvent AmbientChanged(namedProp)
        End If
    End Sub
        
    Protected Sub IOleControlFreezeEvents(ByVal bFreeze As Long) _
            Implements IOleControl.FreezeEvents
        #If LOG_USERCONTROL Then
            Log("IOleControl_FreezeEvents", bFreeze)
        #End If
        InternalBaseControlInfo.EventsAreFrozen = bFreeze <> 0
        
        With CType(Of ITwinBasicInternalClassSupport)(Me)
            .FreezeRaiseEvents(InternalBaseControlInfo.EventsAreFrozen)
        End With
        
        If (InternalBaseControlInfo.EventsAreFrozen = False) And (InternalState.QueuedShowEvent = True) Then
            ' Can't RaiseEvent Show/Hide directly here, as Access doesn't change the internal freeze-event state until we've returned from this call
            ' Switching from DesignView to FormView demonstrates the problem, where we further RaiseEvent on the host inside the Show/Hide implementation
            ScheduleCallbackShow = True
            ControlContext.RuntimeUICtxScheduleCallback(Me)
        End If
    End Sub
    
    Protected ScheduleCallbackShow As Boolean
    Protected ScheduleCallbackResize As Boolean
    
    Protected Sub IScheduledCallbackExecute() _
            Implements IScheduledCallback.Execute
    
        InternalState.IsInResizeCallback = True
        
        If Me.ScheduleCallbackShow Then
            Me.ScheduleCallbackShow = False
            If (InternalBaseControlInfo.EventsAreFrozen = False) And (InternalState.QueuedShowEvent = True) Then
                InternalState.QueuedShowEvent = False
                Dim isWindowVisible As Boolean = (InternalHWND.GetWindowLongW(GWL_STYLE) And WS_VISIBLE) <> 0
                
                
                If isWindowVisible <> InternalState.ConsumerVisibilityState Then
                    InternalState.ConsumerVisibilityState = isWindowVisible
                        
                    If InternalState.IsTbDebugging = False Then
                        On Error Resume Next
                    End If
                        
                    If isWindowVisible Then
                        RaiseEvent Show()
                    Else
                        RaiseEvent Hide()
                    End If
                End If
            End If
        ElseIf Me.ScheduleCallbackResize Then
            Me.ScheduleCallbackResize = False
            Dim HasFinishedLoading As Boolean = Me.InternalState.HasFinishedLoading
            Me.InternalState.IgnorePropertyChangedNotifications += (HasFinishedLoading = False)
            If InternalState.IsTbDebugging = False Then
                On Error Resume Next
            End If
            If InternalState.IsInResizeEvent = False Then
                InternalState.IsInResizeEvent = True
                If InternalState.HasFinishedLoading Then
                    InternalState.HasRaisedInitialResizeEvent = True
                    RaiseEvent Resize()
                End If
                InternalState.IsInResizeEvent = False
            End If
            Me.InternalState.IgnorePropertyChangedNotifications -= (HasFinishedLoading = False)
        End If
        
        InternalState.IsInResizeCallback = False
    End Sub

    Protected Function GetRootCLSIDStr() As String
        ' This works regardless if OnInitialize has been reached yet
        Dim SerializeInfo As SerializeInfo
        SerializeInfo.Pointer = GetClassInstanceSerializer([_HiddenModule].GetInheritedOwner(Me))
        Return SerializeInfo.RuntimeUISrzGetRootCLSID()
    End Function

    Protected Sub IProvideClassInfoGetClassInfo(ByRef ppTI As ITypeInfo) _
            Implements IProvideClassInfo.GetClassInfo
        #If LOG_USERCONTROL Then
            Log("IProvideClassInfo_GetClassInfo")
        #End If
        PutMemPtr(VarPtr(ppTI), vbNullPtr)    ' OUT semantics            
        
        Dim tlib As ITypeLib
        OLEAUT32.LoadTypeLib(Global.App.ModulePath, tlib)
        
        If tlib Is Nothing Then
        GiveBackInternalImplementation:
            Debug.TracePrint "ActiveX TypeLib error: unable to load type info from file [" & Global.App.ModulePath & "]"
            'Debug.Print "ActiveX TypeLib error: unable to load type library from file [" & Global.App.ModulePath & "]"
            'SmartUI requires that we MUST return valid ITypeInfo here
            Dim dispEx As IDispatchInternal
            Set dispEx = Me
            Set ppTI = CType(Of ITypeInfo)(dispEx.GetTypeInfo(0, 0))
            Exit Sub
        End If

        #If LOG_USERCONTROL Then
            Log("TYPELIB: " & ObjPtr(tlib))
        #End If
        
        'InternalIIDFromString(InternalState.RootCLSID, VarPtr(guid))
        Dim guid As GUID2
        OLE32.IIDFromString(GetRootCLSIDStr(), VarPtr(guid))
        tlib.GetTypeInfoOfGuid(guid, ppTI)

        If ppTI Is Nothing Then
            GoTo GiveBackInternalImplementation
        End If

        #If LOG_USERCONTROL Then
            Log("TYPEINFO: " & ObjPtr(ppTI))
        #End If
    End Sub
        
    Protected Sub IViewObjectDraw(ByVal dwDrawAspect As Long, ByVal lindex As Long, ByVal pvAspect As LongPtr, ByVal ptd As LongPtr, ByVal hdcTargetDev As HDC, ByVal hdcDraw As HDC, lprcBounds As tbRECT, lprcWBounds As tbRECT, ByVal pfnContinue As LongPtr, ByVal dwContinue As LongPtr) _
            Implements IViewObject.Draw
        #If LOG_USERCONTROL Then
            Log("IViewObject_Draw", "dwDrawAspect: ", dwDrawAspect, "lindex: ", lindex, "pvAspect: ", Hex(pvAspect), "ptd: ", Hex(ptd), "hdcDraw: ", Hex(hdcDraw), "lprcBounds: ", VarPtr(lprcBounds))
        #End If
        If VarPtr(lprcBounds) <> vbNullPtr Then
            Debug.TracePrint "IViewObject_Draw -> lprcBounds(" & (lprcBounds.Right - lprcBounds.Left) & ", " & (lprcBounds.Bottom - lprcBounds.Top) & ")"
        End If
        
        Dim hwnd As HWND = InternalHWND
                
        If Me.InternalState.IsWindowlessActivated Then
            #If LOG_USERCONTROL Then
                Log("IViewObject_Draw", "*** WINDOWLESS ***", "dwDrawAspect: ", dwDrawAspect, "lindex: ", lindex, "pvAspect: ", Hex(pvAspect), "ptd: ", Hex(ptd), "hdcDraw: ", Hex(hdcDraw))
            #End If
                    
                ' We're drawing into the containers window, so we need to adjust the coordinate system so that drawing occurs offset
                Dim oldViewPort As POINT
                hdcDraw.GetViewportOrgEx(oldViewPort)
                hdcDraw.SetViewportOrgEx(oldViewPort.x + InternalState.WindowlessRect.Left, oldViewPort.y + InternalState.WindowlessRect.Top, ByVal vbNullPtr)
                #If LOG_USERCONTROL Then
                    Log("IViewObject_Draw", "WindowlessRect.Left:", WindowlessRect.Left, "WindowlessRect.Top:", WindowlessRect.Top, "oldViewPort.X:", oldViewPort.X, "oldViewPort.Y:", oldViewPort.Y)
                #End If
                Me.OnPaint(hdcDraw, True)
                hdcDraw.SetViewportOrgEx(oldViewPort.x, oldViewPort.y, ByVal vbNullPtr)
            
                #If LOG_USERCONTROL Then
                    Log("IViewObject_Draw", "--> DONE")
                #End If
                
        ElseIf (VarPtr(lprcBounds) <> 0) And (hdcDraw.Value <> 0) Then
            'If WindowIsInPlace = False Then
            
                ' This method does not work well on older OSes, e.g. Win 7 it will produce black rect due to the OS not allowing capture from offscreen areas
                'Int3Breakpoint
                
                ' #If LOG_USERCONTROL Then
                '     Log("IViewObject_Draw", "dwDrawAspect: ", dwDrawAspect, "lindex: ", lindex, "pvAspect: ", Hex(pvAspect), "ptd: ", Hex(ptd), "hdcDraw: ", Hex(hdcDraw), "lprcBounds.Left: ", lprcBounds.Left, "lprcBounds.Top: ", lprcBounds.Top, "lprcBounds.Right: ", lprcBounds.Right, "lprcBounds.Bottom: ", lprcBounds.Bottom)
                ' #End If
                    
                ' ' This won't actually make the window visible on screen, as the parent is a 0x0 window
                ' '  VBx seems to use this method rather than ShowWindow
                ' Dim oldStyles As Long = GetWindowLongW(hWnd, GWL_STYLE)
                ' #If LOG_USERCONTROL Then
                '     Log("IViewObject_Draw", "oldStyles: ", Hex(oldStyles))
                ' #End If
                
                ' SetWindowLongW(hWnd, GWL_STYLE, oldStyles Or WS_VISIBLE)
                ' 'UpdateWindow(hWnd)          ' FIXME is this needed?
                                
                ' Dim hDC As LongPtr = CreateCompatibleDC(hdcDraw)

                ' Dim _width As Long = lprcBounds.Right - lprcBounds.Left
                ' Dim _height As Long = lprcBounds.Bottom - lprcBounds.Top
                
                ' ' Use the provided width/height for the drawing.  This is needed to support VBA UserForm 'Zoom' property
                ' Dim widthBefore As Double = Me.PixelsWidth * Me.DpiScale
                ' Dim heightBefore As Double = Me.PixelsHeight * Me.DpiScale
                ' #If LOG_USERCONTROL Then
                '     Log("IOleObject_DoVerb", "calling SetWindowPos")
                ' #End If
                
                ' InternalSetWindowPos(Me.hWnd, 0, 0, 0, _width, _height, SWP_NOMOVE Or SWP_NOREDRAW Or SWP_NOOWNERZORDER Or SWP_NOACTIVATE Or SWP_NOZORDER)
                ' #If LOG_USERCONTROL Then
                '     Log("IOleObject_DoVerb", "calling SetWindowPos... DONE", "Me.PixelsWidth(AFTER)", Me.PixelsWidth, "Me.PixelsHeight(AFTER)", Me.PixelsHeight)
                ' #End If
                
                
                ' Dim lpBits As LongPtr = [_HiddenModule].AllocMem(_width * _height * 4)
                ' Dim hbmp As LongPtr = InternalCreateBitmap(_width, _height, 1, 32, lpBits)
                ' Dim oldBitmap As LongPtr = SelectObject(hDC, hbmp)
                
                ' InternalPrintWindow(hWnd, hDC, 0)
                ' BitBlt(hdcDraw, lprcBounds.Left, lprcBounds.Top, Width, Height, hDC, 0, 0, vbSrcCopy)

                ' SelectObject(hDC, oldBitmap)
                ' DeleteDC(hDC)
                ' DeleteObject(hbmp)

                ' [_HiddenModule].FreeMem(lpBits)
                
                ' SetWindowLongW(hWnd, GWL_STYLE, oldStyles)
                
                
                ' #If LOG_USERCONTROL Then
                '     Log("IOleObject_DoVerb", "calling SetWindowPos (reverting)")
                ' #End If
                
                ' InternalSetWindowPos(Me.hWnd, 0, 0, 0, widthBefore, heightBefore, SWP_NOMOVE Or SWP_NOREDRAW Or SWP_NOOWNERZORDER Or SWP_NOACTIVATE Or SWP_NOZORDER)
                ' #If LOG_USERCONTROL Then
                '     Log("IOleObject_DoVerb", "calling SetWindowPos... DONE", "Me.PixelsWidth(AFTER)", Me.PixelsWidth, "Me.PixelsHeight(AFTER)", Me.PixelsHeight)
                ' #End If
                
                ' #If LOG_USERCONTROL Then
                '     Log("IViewObject_Draw", "--> DONE")
                ' #End If
                
                If InternalState.HwndIsParented = False Then       ' if we don't check this, Excel CustomTaskPanes don't get rendered properly (where the HWND is already visible, so why does it call IViewObject::Draw??)
                IsSnapshotting:
                    Dim _width As Long = lprcBounds.Right - lprcBounds.Left
                    Dim _height As Long = lprcBounds.Bottom - lprcBounds.Top
                    Dim oldStyles As Long = hwnd.GetWindowLongW(GWL_STYLE)
                    'Dim oldExStyles As Long = GetWindowLongW(hWnd, GWL_EXSTYLE)
                    hwnd.SetWindowLongW(GWL_STYLE, oldStyles Or WS_VISIBLE)
                
                    Dim hDC As HDC
                    hDC = hDC.CreateCompatibleDC()
                    Dim hbmp As LongPtr = hdcDraw.CreateCompatibleBitmap(_width, _height)
                    Dim oldBitmap As LongPtr = hDC.SelectObject(hbmp)
                    
                    'SendMessageW(hWnd, WM_ERASEBKGND, hDC, 0) 'Causes double _Print event to be fired due to it already firing from our internal WM_PRINTCLIENT implementation
                    Dim oldRect As tbRECT
                    hwnd.GetWindowRect(oldRect)
                    'InternalSetWindowPos(hWnd, 0, 0, 0, _width, _height, SWP_NOMOVE Or SWP_NOREDRAW Or SWP_NOOWNERZORDER Or SWP_NOACTIVATE Or SWP_NOZORDER)
                    hwnd.SetWindowPos(0, 0, 0, _width, _height, SWP_NOACTIVATE)
                    hwnd.SendMessageW(WM_PRINTCLIENT, hDC.Value, &H80000006&)    ' client and non-client area plus flag only used by us
                    hdcDraw.BitBlt(lprcBounds.Left, lprcBounds.Top, _width, _height, hDC, 0, 0, vbSrcCopy)
                    hwnd.SetWindowLongW(GWL_STYLE, oldStyles)
                    hDC.SelectObject(oldBitmap)
                    GDI32.DeleteObject(hbmp)
                    hDC.DeleteDC()
                    hwnd.SetWindowPos(0, oldRect.Left, oldRect.Top, oldRect.Right - oldRect.Left, oldRect.Bottom - oldRect.Top, SWP_NOACTIVATE)
                    'WindowsAPI.InvalidateRect(hWnd, vbNullPtr, 0)                    
                Else
                    ' check if we're being painted as part of an IDE snapshot
                    ' this is basically done for Excel CTP support, where doing the above snapshot causes issues if the control is actually already visible/rendered on screen
                    Dim testRect As tbRECT
                    Dim parent As HWND = InternalState.ContainerWindow
                    
                    While parent.Value <> 0
                        parent.GetClientRect(testRect)
                        'Debug.Print testRect.Right, testRect.Left, testRect.Bottom, testRect.Top
                        If ((testRect.Right - testRect.Left) = 0) And ((testRect.Bottom - testRect.Top) = 0) Then
                            GoTo IsSnapshotting
                        End If
                        parent = parent.GetParent()
                    Wend
                End If
                
           ' End If

            If hwnd.Value <> 0 Then
                'Debug.Print "IViewObject_Draw", Hex(hWnd), lprcBounds.Right - lprcBounds.Left, lprcBounds.Bottom - lprcBounds.Top
                'SetWindowPos(hWnd, 0, lprcBounds.Left, lprcBounds.Top, lprcBounds.Right - lprcBounds.Left, lprcBounds.Bottom - lprcBounds.Top, 0)
                'Me.PixelsLeft = lprcBounds.Left
                'Me.PixelsTop = lprcBounds.Top
                'Me.PixelsWidth = lprcBounds.Right - lprcBounds.Left
                'Me.PixelsHeight = lprcBounds.Bottom - lprcBounds.Top
                'Me.InternalMove(Me, lprcBounds.Left, lprcBounds.Top, lprcBounds.Right - lprcBounds.Left, lprcBounds.Bottom - lprcBounds.Top)
                'Me.ControlContext.ChangedPosition()
            End If
        End If
        
        #If LOG_USERCONTROL Then
            Log("IViewObject_Draw ... DONE", VarPtr(lprcBounds))
        #End If
    End Sub
    
    Protected Sub IViewObjectGetColorSet(ByVal dwDrawAspect As Long, ByVal lindex As Long, ByVal pvAspect As LongPtr, ByVal ptd As LongPtr, ByVal hicTargetDev As LongPtr, ByVal ppColorSet As LongPtr) _
            Implements IViewObject.GetColorSet
        #If LOG_USERCONTROL Then
            Log("IViewObject_GetColorSet", dwDrawAspect, lindex, pvAspect, ptd, hicTargetDev, ppColorSet)
        #End If
    End Sub
    
    Protected Sub IViewObjectFreeze(ByVal dwDrawAspect As Long, ByVal lindex As Long, ByVal pvAspect As LongPtr, pdwFreeze As Long) _
            Implements IViewObject.Freeze
        #If LOG_USERCONTROL Then
            Log("IViewObject_Freeze", dwDrawAspect, lindex, pvAspect)
        #End If
    End Sub
    
    Protected Sub IViewObjectUnfreeze(ByVal dwFreeze As Long) _
            Implements IViewObject.Unfreeze
        #If LOG_USERCONTROL Then
            Log("IViewObject_Unfreeze", dwFreeze)
        #End If
    End Sub
    
    Protected Sub IViewObjectSetAdvise(ByVal aspects As Long, ByVal advf As Long, ByVal pAdvSink As VBRUN.tbInternal_IAdviseSink) _
            Implements IViewObject.SetAdvise
        #If LOG_USERCONTROL Then
            Log("IViewObject_SetAdvise", aspects, advf, ObjPtr(pAdvSink))
        #End If
        Set InternalState.IViewObject_adviseSink = pAdvSink
        
        'Debug.Print "UserControl IViewObject_SetAdvise"
    End Sub
    
    Protected Sub IViewObjectGetAdvise(pAspects As Long, pAdvf As Long, ppAdvSink As VBRUN.tbInternal_IAdviseSink) _
            Implements IViewObject.GetAdvise
        #If LOG_USERCONTROL Then
            Log("IViewObject_GetAdvise", pAspects, pAdvf, ObjPtr(ppAdvSink))
        #End If
        PutMemPtr(VarPtr(ppAdvSink), vbNullPtr)    ' OUT semantics                    
        Set ppAdvSink = InternalState.IViewObject_adviseSink
        
        If ppAdvSink Is Nothing Then
            Err.ReturnHResult = &H800AFFFF  ' must return an error, so that the caller doesn't assume we populated ppClientSite and cause a nullptr deref
        End If
    End Sub
    
    
    Protected Sub Draw(ByVal dwDrawAspect As Long, ByVal lindex As Long, ByVal pvAspect As LongPtr, _ 
                ByVal ptd As LongPtr, ByVal hdcTargetDev As HDC, ByVal hdcDraw As HDC, _
                ByRef lprcBounds As tbRECT, ByRef lprcWBounds As tbRECT, ByVal pfnContinue As LongPtr, ByVal dwContinue As LongPtr) _
            Implements IViewObjectEx.Draw
        IViewObjectDraw(dwDrawAspect, lindex, pvAspect, ptd, hdcTargetDev, hdcDraw, lprcBounds, lprcWBounds, pfnContinue, dwContinue)
    End Sub
    Protected Sub GetColorSet(ByVal dwDrawAspect As Long, ByVal lindex As Long, ByVal pvAspect As LongPtr, _ 
                ByVal ptd As LongPtr, ByVal hicTargetDev As LongPtr, ByVal ppColorSet As LongPtr) _
            Implements IViewObjectEx.GetColorSet
        IViewObjectGetColorSet(dwDrawAspect, lindex, pvAspect, ptd, ByVal hicTargetDev, ppColorSet)
    End Sub
    Protected Sub Freeze(ByVal dwDrawAspect As Long, ByVal lindex As Long, ByVal pvAspect As LongPtr, ByRef pdwFreeze As Long) _
            Implements IViewObjectEx.Freeze
        IViewObjectFreeze(dwDrawAspect, lindex, pvAspect, pdwFreeze)
    End Sub
    Protected Sub Unfreeze(ByVal dwFreeze As Long) _
            Implements IViewObjectEx.Unfreeze
        IViewObjectUnfreeze(dwFreeze)
    End Sub
    Protected Sub SetAdvise(ByVal aspects As Long, ByVal advf As Long, ByVal pAdvSink As VBRUN.tbInternal_IAdviseSink) _
            Implements IViewObjectEx.SetAdvise
        IViewObjectSetAdvise(aspects, advf, pAdvSink)
    End Sub
    Protected Sub GetAdvise(ByRef pAspects As Long, ByRef pAdvf As Long, ByRef ppAdvSink As VBRUN.tbInternal_IAdviseSink) _
            Implements IViewObjectEx.GetAdvise
        IViewObjectGetAdvise(pAspects, pAdvf, ppAdvSink)
    End Sub
    Protected Sub IGetExtent(ByVal dwDrawAspect As Long, ByVal lindex As Long, ByVal ptd As LongPtr, ByRef lpsizel As SIZEL) _
            Implements IViewObjectEx.GetExtent
        #If LOG_USERCONTROL Then
            Log("IViewObjectEx_GetExtent", dwDrawAspect, lindex, Hex(ptd))
        #End If
        IOleObjectGetExtent(dwDrawAspect, lpsizel)
    End Sub
    Protected Sub GetRect(ByVal dwAspect As Long, ByRef pRect As tbRECT) _
            Implements IViewObjectEx.GetRect
        #If LOG_USERCONTROL Then
            Log("IViewObjectEx_GetRect", dwAspect)
        #End If
        LSet pRect = InternalState.WindowlessRect
    End Sub
    Protected Sub GetViewStatus(ByRef pdwStatus As Long) _
            Implements IViewObjectEx.GetViewStatus
        #If LOG_USERCONTROL Then
            Log("IViewObjectEx_GetViewStatus")
        #End If
        If Me.BackStyle = BackFillStyleConstants.vbBFOpaque Then
        	pdwStatus = 1 ' VIEWSTATUS_OPAQUE
        Else
            pdwStatus = 0   ' transparent
        End If
        /*
        VIEWSTATUS_OPAQUE = 1,
        VIEWSTATUS_SOLIDBKGND = 2,
        VIEWSTATUS_DVASPECTOPAQUE = 4,
        VIEWSTATUS_DVASPECTTRANSPARENT = 8,
        VIEWSTATUS_SURFACE = 16,
        VIEWSTATUS_3DSURFACE = 32
        */
    End Sub
    Protected Sub QueryHitPoint(ByVal dwAspect As Long, ByRef pRectBounds As tbRECT, ByVal ptlLocXY As LongLong, ByVal lCloseHint As Long, ByRef pHitResult As Long) _
            Implements IViewObjectEx.QueryHitPoint
        #If LOG_USERCONTROL Then
            Log("IViewObjectEx_QueryHitPoint")
        #End If
        
        If InternalState.IsWindowlessActivated And (BackStyle = BackFillStyleConstants.vbBFTransparent) Then
            Dim hitResult As Integer = CInt(vbHitResultTransparent)       ' I think HitTestBehaviour affects this initial value
            Dim X As Single = CSng(ptlLocXY And &HFFFFFFFF^)
            Dim Y As Single = CSng(ptlLocXY >> 16 >> 16)     ' FIXME >> bug
            If InternalState.IsTbDebugging = False Then
                On Error Resume Next
            End If
            RaiseEvent HitTest(CSng(X - pRectBounds.Left), CSng(Y - pRectBounds.Top), hitResult)
            pHitResult = hitResult
        Else
            pHitResult = vbHitResultHit
        End If
    End Sub
    Protected Sub QueryHitRect(ByVal dwAspect As Long, ByRef pRectBounds As tbRECT, ByRef pRectLoc As tbRECT, ByVal lCloseHint As Long, ByRef pHitResult As Long) _
            Implements IViewObjectEx.QueryHitRect
        #If LOG_USERCONTROL Then
            Log("IViewObjectEx_QueryHitRect")
        #End If
        
        Err.ReturnHResult = E_NOTIMPL
    End Sub
    Protected Sub GetNaturalExtent(ByVal dwAspect As Long, ByVal lindex As Long, ByVal ptd As LongPtr, ByVal hicTargetDev As LongPtr, ByVal pExtentInfo As LongPtr, ByRef pSizel As SIZEL) _
            Implements IViewObjectEx.GetNaturalExtent
        #If LOG_USERCONTROL Then
            Log("IViewObjectEx_GetNaturalExtent")
        #End If
        
        Err.ReturnHResult = E_NOTIMPL
    End Sub


    Protected Sub IPersistStorageInitNew(ByVal pStg As IStorage) _
            Implements VB.IPersistStorage.InitNew
        #If LOG_USERCONTROL Then
            Log("IPersistStorage_InitNew", ObjPtr(pStg))
        #End If
        
        If InternalState.IsInitialized = False Then InitializeMe
        If InternalState.IsTbDebugging = False Then
            On Error Resume Next
        End If
        RaiseEvent InitProperties()
        InternalState.HasFinishedLoading = True
        
        HandleInitialNewControlSize()
    End Sub
    
    Protected Sub IPersistStorageLoad(ByVal pStg As IStorage) _
            Implements VB.IPersistStorage.Load
        'Dim A As String = "IPersistStorage_Load"
        #If LOG_USERCONTROL Then
            Log("IPersistStorage_Load", ObjPtr(pStg))
        #End If

        On Error GoTo StreamError

        Dim stream As IStream
        pStg.OpenStream(StrPtr("DATA"), 0, STGM_READ Or STGM_SHARE_EXCLUSIVE, 0, stream)
        #If LOG_USERCONTROL Then
            Log("IPersistStorage_Load", ObjPtr(pStg), ObjPtr(stream))
        #End If
        
        IPersistStreamLoad(stream)
        
        #If LOG_USERCONTROL Then
            Log("IPersistStorage_Load", ObjPtr(pStg), "... DONE")
        #End If
        
        Exit Sub
        
StreamError:
        MsgBox("ActiveX Stream Error: " & Hex(Err.Number) & ", " & Err.Description)
        Err.ReturnHResult = &H800AEAEA
    End Sub

    Protected Sub IPersistStorageSave(ByVal pStg As IStorage) _
            Implements VB.IPersistStorage.Save
        #If LOG_USERCONTROL Then
            Log("IPersistStorage_Save", ObjPtr(pStg))
        #End If
        
        On Error GoTo StreamError

        Dim stream As IStream
        pStg.CreateStream(StrPtr("DATA"), STGM_CREATE Or STGM_READWRITE Or STGM_SHARE_EXCLUSIVE, 0, 0, stream)
        #If LOG_USERCONTROL Then
            Log("IPersistStorage_Save", ObjPtr(pStg), " [1]", ObjPtr(stream))
        #End If
        
        IPersistStreamSave(stream, 1)
        
        #If LOG_USERCONTROL Then
            Log("IPersistStorage_Save", ObjPtr(pStg), "... DONE")
        #End If
        Exit Sub
        
    StreamError:
        MsgBox("ActiveX Stream Error: " & Hex(Err.Number) & ", " & Err.Description)
    End Sub

    Protected Sub IPersistStorageSaveCompleted(ByVal pStgNew As IStorage) _
            Implements VB.IPersistStorage.SaveCompleted
        #If LOG_USERCONTROL Then
            Log("IPersistStorage_SaveCompleted", ObjPtr(pStgNew))
        #End If
    End Sub

    Protected Sub IPersistStorageHandsOffStorage() _
            Implements VB.IPersistStorage.HandsOffStorage
        #If LOG_USERCONTROL Then
            Log("IPersistStorage_HandsOffStorage")
        #End If
    End Sub
    
    Protected Sub UnsupportedInterfaceRequested(ByRef iid As GUID2, ByRef out As stdole.IUnknown) _
            Implements IUnsupportedInterface.UnsupportedInterfaceRequested
        Dim temp As String = String$(40, " ")
        OLE32.StringFromGUID2(iid, StrPtr(temp), 40)
        #If LOG_USERCONTROL Then
            Log("UNSUPPORTED-INTERFACE: " & temp)
        #End If
    End Sub
    
    Sub Refresh()
    	If Me.Windowless = True Then
            Dim ContainerHwnd As HWND = Me.ContainerHwnd
            ContainerHwnd.InvalidateRect(Me.InternalState.WindowlessRect, 1)
            'USER32_RedrawWindow(Me.RootWindowElementBase, 0, 0, RDW_ERASE Or RDW_INVALIDATE Or RDW_UPDATENOW)
        Else
            RootWindowElementBase.RedrawWindow(0, 0, RDW_ERASE Or RDW_INVALIDATE Or RDW_UPDATENOW)
        End If
    End Sub
    
    Protected Sub InPlaceDeactivate() _
            Implements IOleInPlaceObject.InPlaceDeactivate
        #If LOG_USERCONTROL Then
            Log("IOleInPlaceObject_InPlaceDeactivate")
        #End If
        
        Debug.TracePrint "IOleInPlaceObject_InPlaceDeactivate *** 1"
        
        If InternalState.ConsumerVisibilityState = True Then
            InternalState.ConsumerVisibilityState = False
            If InternalState.IsTbDebugging = False Then
                On Error Resume Next
            End If
            RaiseEvent Hide()
            On Error GoTo 0
        End If

        Debug.TracePrint "IOleInPlaceObject_InPlaceDeactivate *** 2"
        
        #If LOG_USERCONTROL Then
            Log("IOleInPlaceObject_InPlaceDeactivate", 1)
        #End If
        
'        Stop
        Dim site As IOleInPlaceSite = CType(Of IOleInPlaceSite)(InternalState.OleClientSite)
        On Error Resume Next
        site.OnUIDeactivate(0)
        
        If Err.Number <> 0 Then
            #If LOG_USERCONTROL Then
                Log("IOleInPlaceObject_InPlaceDeactivate", "OnUIDeactivate Err.Number:", Hex(Err.Number))
            #End If
            Err.Clear
        End If
        
        Debug.TracePrint "IOleInPlaceObject_InPlaceDeactivate *** 3"
        

        #If LOG_USERCONTROL Then
            Log("IOleInPlaceObject_InPlaceDeactivate", 2)
        #End If
        
        Debug.TracePrint "IOleInPlaceObject_InPlaceDeactivate *** 4"
        
        Dim controlSite As Any = CType(Of IOleControlSite)(InternalState.OleClientSite)
        controlSite.OnFocus(0)

        If Err.Number <> 0 Then
            #If LOG_USERCONTROL Then
                Log("IOleInPlaceObject_InPlaceDeactivate", "controlSite.OnFocus(0) Err.Number:", Hex(Err.Number))
            #End If
            Err.Clear
        End If

        #If LOG_USERCONTROL Then
            Log("IOleInPlaceObject_InPlaceDeactivate", 3)
        #End If
        
        If InternalState.IsTbDebugging = False Then
            On Error Resume Next
        End If
        
        Debug.TracePrint "IOleInPlaceObject_InPlaceDeactivate *** 5"
        
        'If InternalState.hasFocusOnChild = True Then RaiseEvent ExitFocus()
        If InternalState.hasFocus = True Then RaiseEvent LostFocus()
                
        #If LOG_USERCONTROL Then
            Log("IOleInPlaceObject_InPlaceDeactivate", 4)
        #End If
        
        Debug.TracePrint "IOleInPlaceObject_InPlaceDeactivate *** 6"
        
        
        ' Doing this causes problems with controls sited on Excel/VBA multi-page control
        ' when switching between pages, VBA UserForm invokes IOleInPlaceObject_InPlaceDeactivate
        ' and the below call then triggers WM_DESTROY to be sent to our window, presumably because the container HWND is destroyed
        ' So first, we detach ourselves from the parent, so that we don't receive WM_DESTROY
        'Debug.TracePrint "*** DEACTIVATE.0"
        RootWindowElementBase.RuntimeUIGetHandle().ShowWindow(SW_HIDE)
        'Debug.TracePrint "*** DEACTIVATE.1"
        'DoEvents()  ' only added for testing
        'Debug.TracePrint "*** DEACTIVATE.2"
        RootWindowElementBase.RuntimeUIGetHandle().SetParent(InternalState.OriginalParentHWND)       ' important: don't use 0 here, as we need it to remain hidden if drawn behind the scenes (e.g. Access ctrl Enabled=False)
        InternalState.HwndIsParented = False
        site.OnInPlaceDeactivate()
        InternalState.WindowIsInPlace = False
        'Set siteFrame = Nothing
        
        If Err.Number <> 0 Then
            #If LOG_USERCONTROL Then
                Log("IOleInPlaceObject_InPlaceDeactivate", "site.OnInPlaceDeactivate Err.Number:", Hex(Err.Number))
            #End If
            Err.Clear
        End If
        
        Debug.TracePrint "IOleInPlaceObject_InPlaceDeactivate *** 7"
        
    End Sub
    
    Protected Sub GetWindow(phwnd As HWND) _
            Implements IOleInPlaceObject.GetWindow, _
                        IOleInPlaceActiveObject.GetWindow
        #If LOG_USERCONTROL Then
            Log("IOleInPlaceObject_GetWindow")
        #End If
        
        If Me.InternalState.IsWindowlessActivated Then
        	phwnd = 0
            Exit Sub
        End If
        
        Dim RootWindowElementBase As Any = Me.RootWindowElementBase
        phwnd = RootWindowElementBase.RuntimeUIGetHandle()
        
        #If LOG_USERCONTROL Then
            Log("IOleInPlaceObject_GetWindow... DONE, returned: ", phwnd)
        #End If
    End Sub
    
    Protected Sub ContextSensitiveHelp(ByVal fEnterMode As Long) _
            Implements IOleInPlaceObject.ContextSensitiveHelp, _
                        IOleInPlaceActiveObject.ContextSensitiveHelp
        #If LOG_USERCONTROL Then
            Log("IOleInPlaceObject_ContextSensitiveHelp")
        #End If
        
'        Stop
    End Sub
    
    Protected Sub ReactivateAndUndo() Implements IOleInPlaceObject.ReactivateAndUndo
        #If LOG_USERCONTROL Then
            Log("IOleInPlaceObject_ReactivateAndUndo")
        #End If
        
'        Stop
    End Sub
        
    'Protected Sub LogRect(s As String, Left As Long, Top As Long, Right As Long, Bottom As Long)
        
    'End Sub
        
    Protected Sub SetObjectRects(lprcPosRect As tbRECT, lprcClipRect As tbRECT) _
            Implements IOleInPlaceObject.SetObjectRects
        Dim RootWindowElementBase As Any = Me.RootWindowElementBase
        
        'lprcClipRect.Right = lprcPosRect.Right - 200           ' to test clipping
       
        'LogRect("SetObjectRects.lprcPosRect", lprcPosRect.Left, lprcPosRect.Top, lprcPosRect.Right, lprcPosRect.Bottom)
        'LogRect("SetObjectRects.lprcClipRect", lprcClipRect.Left, lprcClipRect.Top, lprcClipRect.Right, lprcClipRect.Bottom)
        'Debug.TracePrint "SetObjectRects: raw " And VarPtr(lprcPosRect) & ", " And VarPtr(lprcClipRect)
        'If VarPtr(lprcPosRect) <> 0 Then Debug.TracePrint "SetObjectRects: rect:{" + lprcPosRect.Left & ", " & lprcPosRect.Top & ", " & (lprcPosRect.Right - lprcPosRect.Left) & ", " & (lprcPosRect.Bottom - lprcPosRect.Top) & "}"
        'If VarPtr(lprcClipRect) <> 0 Then Debug.TracePrint "SetObjectRects: clip:{" + lprcClipRect.Left & ", " & lprcClipRect.Top & ", " & (lprcClipRect.Right - lprcClipRect.Left) & ", " & (lprcClipRect.Bottom - lprcClipRect.Top) & "}"
        USER32.IntersectRect(InternalState.ClippedRect, lprcPosRect, lprcClipRect)
        
        'LogRect("SetObjectRects.ClippedRect", InternalState.ClippedRect.Left, InternalState.ClippedRect.Top, InternalState.ClippedRect.Right, InternalState.ClippedRect.Bottom)
        
       
        Dim IsClipped As Boolean
        If USER32.EqualRect(InternalState.ClippedRect, lprcPosRect) = 0 Then
            IsClipped = True
           ' The region of our HWND needs to be clipped.
           ' FIXME when clipped, the resize event doesn't fire here           
           ' FIXME this will need work to support windowless controls
        End If
              
        If Me.Windowless Then
            LSet InternalState.WindowlessRect = lprcPosRect
        Else
            'InternalSleep(2000)
            ' Static temp As Long
            ' If temp > 0 Then
            '     DoEvents
            '     Exit Sub
            ' End If
            ' temp += 1
            
            ' FIXME check if the window position is actually changed, otherwise avoid MoveWindow (which results in flickering in iGrid Access forms mousewheel messages?)
            InternalState.MutedResizeEventsCount += 1
            RootWindowElementBase.RuntimeUIGetHandle().MoveWindow(lprcPosRect.Left, lprcPosRect.Top, lprcPosRect.Right - lprcPosRect.Left, lprcPosRect.Bottom - lprcPosRect.Top, 1)
            InternalState.MutedResizeEventsCount -= 1
            
            If IsClipped Or InternalState.WindowRgnIsClipped Or InternalState.WindowRgnIsPending Then
                ' Reposition the rect so that it refers to the 0,0 position, ready for SetWindowRgn
                USER32.OffsetRect(InternalState.ClippedRect, -InternalState.ClippedRect.Left, -InternalState.ClippedRect.Top)
                
                'LogRect("SetObjectRects.POSTING", InternalState.ClippedRect.Left, InternalState.ClippedRect.Top, InternalState.ClippedRect.Right, InternalState.ClippedRect.Bottom)
                
                InternalState.WindowRgnIsPending = True
                ' FIXME only post this message if the MoveWindow() resulted in a WM_WINDOWPOSCHANGED
                RootWindowElementBase.RuntimeUIGetHandle().PostMessageW(WM_TB_INTERNAL_SELF_DEFERRED_MESSAGE, SELF_DEFFERED_CLIP, 0)
            End If
        End If
       
        ' FIXME resize event should fire here IF the window position changed? (but not when clipped?)
        'Me.ControlContext.ChangedPosition()      ' This sorts out anchoring and docking within the UC
       
       ' FIXME check what happens when this call happens twice with the same arguments
       
       'Debug.TracePrint "IOleInPlaceObject_SetObjectRects lprcPosRect.Left: " & lprcPosRect.Left & " .Top: " & lprcPosRect.Top & " .Right: " & lprcPosRect.Right & " .Bottom: " & lprcPosRect.Bottom & " HEIGHT: " & (lprcPosRect.Bottom - lprcPosRect.Top)
       'InternalSetWindowPos(RootWindowElementBase.Handle, 0, lprcPosRect.Left, lprcPosRect.Top, (lprcPosRect.Right - lprcPosRect.Left), (lprcPosRect.Bottom - lprcPosRect.Top), 0)
       
       'Exit Sub
       
       
    '     #If LOG_USERCONTROL Then
    '         Log("IOleInPlaceObject_SetObjectRects", "VarPtr(lprcPosRect)", VarPtr(lprcPosRect), "VarPtr(lprcClipRect)", VarPtr(lprcClipRect))
    '     #End If
    '     If VarPtr(lprcPosRect) <> 0 Then
    '         #If LOG_USERCONTROL Then
    '             Log("IOleInPlaceObject_SetObjectRects", "width:", lprcPosRect.Right - lprcPosRect.Left, "height:", lprcPosRect.Bottom - lprcPosRect.Top)
    '         #End If
    '     Else
    '         Exit Sub
    '     End If

    '     Dim NoChange As Boolean = False
        
    '     Dim newLeft As Double = lprcPosRect.Left / RootWindowElementBase.UnitPixelScale
    '     Dim newTop As Double = lprcPosRect.Top / RootWindowElementBase.UnitPixelScale
    '     Dim newWidth As Double = (lprcPosRect.Right - lprcPosRect.Left) / RootWindowElementBase.UnitPixelScale
    '     Dim newHeight As Double = (lprcPosRect.Bottom - lprcPosRect.Top) / RootWindowElementBase.UnitPixelScale
        
    '     If Me.Windowless Then
    '         #If LOG_USERCONTROL Then
    '             Log("IOleInPlaceObject_SetObjectRects *** WINDOWLESS")
    '         #End If
    '         LSet InternalState.WindowlessRect = lprcPosRect
            
    '         NoChange = (Me.PixelsLeft = newLeft) AndAlso (Me.PixelsTop = newTop) AndAlso _
    '                    (Me.PixelsWidth = newWidth) AndAlso (Me.PixelsHeight = newHeight)
    '     Else
            
    '         ' FIXME instead of doing this, VB6 seems to just call MoveWindow() and then this logic happens in WM_WINDOWPOSCHANGED instead
    '         Dim windowRect As tbRECT
    '         GetWindowRect(RootWindowElementBase.Handle, windowRect)
    '         Dim parentHwnd As LongPtr = GetParent(RootWindowElementBase.Handle)
    '         Dim topLeftPoint As POINT
    '         topLeftPoint.x = windowRect.Left
    '         topLeftPoint.y = windowRect.Top
    '         ScreenToClient(parentHwnd, topLeftPoint)
    '         Dim bottomRightPoint As POINT
    '         bottomRightPoint.x = windowRect.Right
    '         bottomRightPoint.y = windowRect.Bottom
    '         ScreenToClient(parentHwnd, bottomRightPoint)
            
    '         Debug.TracePrint "IOleInPlaceObject_SetObjectRects windowRect.Left: " & topLeftPoint.x
    '         Debug.TracePrint "IOleInPlaceObject_SetObjectRects windowRect.Top: " & topLeftPoint.y
    '         Debug.TracePrint "IOleInPlaceObject_SetObjectRects windowRect.Right: " & bottomRightPoint.x
    '         Debug.TracePrint "IOleInPlaceObject_SetObjectRects windowRect.Bottom: " & bottomRightPoint.y
    '         Debug.TracePrint "IOleInPlaceObject_SetObjectRects lprcPosRect.Left: " & lprcPosRect.Left
    '         Debug.TracePrint "IOleInPlaceObject_SetObjectRects lprcPosRect.Top: " & lprcPosRect.Top
    '         Debug.TracePrint "IOleInPlaceObject_SetObjectRects lprcPosRect.Right: " & lprcPosRect.Right
    '         Debug.TracePrint "IOleInPlaceObject_SetObjectRects lprcPosRect.Bottom: " & lprcPosRect.Bottom
            
    '         NoChange = (topLeftPoint.x = lprcPosRect.Left) AndAlso (topLeftPoint.y = lprcPosRect.Top) AndAlso _
    '                 (bottomRightPoint.x = lprcPosRect.Right) AndAlso (bottomRightPoint.y = lprcPosRect.Bottom)
    '     End If
        
    '     If NoChange Then
    '         Debug.TracePrint "IOleInPlaceObject_SetObjectRects", "*** NO CHANGE"
    '         #If LOG_USERCONTROL Then
    '             Log("IOleInPlaceObject_SetObjectRects", "*** NO CHANGE")
    '         #End If
    '         Exit Sub
    '         If InternalState.InitialResizeEventFired = False Then
    '             Dim HasFinishedLoading As Boolean = Me.InternalState.HasFinishedLoading
    '             Me.InternalState.IgnorePropertyChangedNotifications += (HasFinishedLoading = False)
                
    '             If InternalState.IsTbDebugging = False Then
    '                 On Error Resume Next
    '             End If
    '             RaiseEvent Resize()
    '             Me.InternalState.IgnorePropertyChangedNotifications -= (HasFinishedLoading = False)
    '             InternalState.InitialResizeEventFired = True
    '         End If
    '         Exit Sub
    '     End If
        
    '     Debug.TracePrint "IOleInPlaceObject_SetObjectRects", "*** CHANGE DETECTED"
        
    '     #If LOG_USERCONTROL Then
    '         Log("IOleInPlaceObject_SetObjectRects", "*** CHANGE DETECTED!")
    '     #End If
    '     InternalState.MutedResizeEventsCount += 1
    '     '    Me.PixelsLeft = newLeft
    '     '    Me.PixelsTop = newTop
    '     '    Me.PixelsWidth = newWidth
    '    '     Me.PixelsHeight = newHeight
    '         InternalSetWindowPos(RootWindowElementBase.Handle, 0, lprcPosRect.Left, lprcPosRect.Top, lprcPosRect.Right - lprcPosRect.Left, lprcPosRect.Bottom - lprcPosRect.Top, SWP_NOACTIVATE)
    '   ' MsgBox "Me.PixelsHeight: " & Me.PixelsHeight & ", newHeight: " & newHeight
    '   InternalState.MutedResizeEventsCount -= 1
 
    '     'Debug.Print Now() & " **** CHANGED WIDTH: " & Me.PixelsWidth
    '     'Stop
    '     'Me.InternalMove(Me, lprcPosRect.Left, lprcPosRect.Top, lprcPosRect.Right - lprcPosRect.Left, lprcPosRect.Bottom - lprcPosRect.Top)
    '     Me.ControlContext.ChangedPosition()
    '     InternalRaiseResize()
    End Sub
    
    Protected Sub IOleInPlaceObjectUIDeactivate() _
            Implements IOleInPlaceObject.UIDeactivate
        #If LOG_USERCONTROL Then
            Log("IOleInPlaceObject_UIDeactivate")
        #End If
                
        RootWindowElementBase.RuntimeUIDeactivateStart()
        
        'Dim controlSite As IOleControlSite = OleClientSite
        'controlSite.OnFocus(0)
        
        Dim inPlaceSite As Any = CType(Of IOleInPlaceSite)(InternalState.OleClientSite)
        On Error Resume Next
        Debug.TracePrint "*** IOleInPlaceObject_UIDeactivate STARTED"
        inPlaceSite.OnUIDeactivate(0)           ' this is needed, else once we get focus, other controls stop working in UserForms
        Debug.TracePrint "*** IOleInPlaceObject_UIDeactivate DONE"
        'DoEvents()      ' needed, otherwise two iGrids on same form cause freeze due to fighting over focus.   removed 03-Jun-25 as it was causing issues with two iGrids when clicking between them (issue #4)

        RootWindowElementBase.RuntimeUIDeactivateEnd()
        
    End Sub
    
    Protected Sub IOleInPlaceObjectWindowlessGetWindow(ByRef phwnd As HWND) _
            Implements IOleInPlaceObjectWindowless.GetWindow
        #If LOG_USERCONTROL Then
            Log("IOleInPlaceObjectWindowless_GetWindow")
        #End If
        phwnd = 0       ' windowless
    End Sub
    Protected Sub IOleInPlaceObjectWindowlessContextSensitiveHelp(ByVal fEnterMode As Long) _
            Implements IOleInPlaceObjectWindowless.ContextSensitiveHelp
        #If LOG_USERCONTROL Then
            Log("IOleInPlaceObjectWindowless_ContextSensitiveHelp", fEnterMode)
        #End If
    End Sub
    Protected Sub IOleInPlaceObjectWindowlessInPlaceDeactivate() _
            Implements IOleInPlaceObjectWindowless.InPlaceDeactivate
        #If LOG_USERCONTROL Then
            Log("IOleInPlaceObjectWindowless_InPlaceDeactivate")
        #End If
    	InPlaceDeactivate()
    End Sub
    Protected Sub IOleInPlaceObjectWindowlessUIDeactivate() _
            Implements IOleInPlaceObjectWindowless.UIDeactivate
        # If LOG_USERCONTROL Then
            Log("IOleInPlaceObjectWindowless_UIDeactivate")
        #End If
    	IOleInPlaceObjectUIDeactivate()
    End Sub
    Protected Sub IOleInPlaceObjectWindowlessSetObjectRects(ByRef lprcPosRect As tbRECT, ByRef lprcClipRect As tbRECT) _
            Implements IOleInPlaceObjectWindowless.SetObjectRects
        #If LOG_USERCONTROL Then
            Log("IOleInPlaceObjectWindowless_SetObjectRects")
        #End If
    	SetObjectRects(lprcPosRect, lprcClipRect)
    End Sub
    Protected Sub IOleInPlaceObjectWindowlessReactivateAndUndo() _
            Implements IOleInPlaceObjectWindowless.ReactivateAndUndo
        #If LOG_USERCONTROL Then
            Log("IOleInPlaceObjectWindowless_ReactivateAndUndo")
        #End If
    	ReactivateAndUndo()
    End Sub
    
    Protected MouseCapturingControl As Control = Nothing
    Protected Sub BeginWindowlessMouseCapture(targetControl As Control)
        #If LOG_USERCONTROL Then
            Log("BeginWindowlessMouseCapture", targetControl.Name)
        #End If
        On Error Resume Next
        Dim siteWindowless As Any = CType(Of IOleInPlaceSiteWindowless)(InternalState.OleClientSite)
        siteWindowless.SetCapture(1)
        Set MouseCapturingControl = targetControl
    End Sub
    Protected Function EndWindowlessMouseCapture(targetControl As Control) As Boolean
        #If LOG_USERCONTROL Then
            Log("EndWindowlessMouseCapture")
        #End If
        
        If MouseCapturingControl Is targetControl Then
            #If LOG_USERCONTROL Then
                Log("EndWindowlessMouseCapture", targetControl.Name)
            #End If
            
            Set MouseCapturingControl = Nothing
            On Error Resume Next
            Dim siteWindowless As Any = CType(Of IOleInPlaceSiteWindowless)(InternalState.OleClientSite)
            siteWindowless.SetCapture(0)
            Return True
        End If
        Return False
    End Function
    
'        Protected IsSettingFocusToUs As Boolean
    Protected Sub IOleInPlaceObjectWindowlessOnWindowMessage(ByVal msg As Long, ByVal wParam As LongPtr, ByVal lParam As LongPtr, ByRef lpResult As LongPtr) _
            Implements IOleInPlaceObjectWindowless.OnWindowMessage
        #If LOG_USERCONTROL Then
            Log("IOleInPlaceObjectWindowless_OnWindowMessage", Hex(msg), Hex(wParam), Hex(lParam))
        #End If
        
        Dim x As Long
        Dim y As Long
        Dim targetControl As Control
        Dim mouseEventName As String
        Dim eventNeedsArgs As Boolean = True
        Dim setMouseCapture As Boolean = False
        Dim releaseMouseCapture As Boolean = False
        Dim shiftState As Integer
        
        Select Case msg
            Case WM_SETFOCUS
                InternalState.hasFocus = True
                'If IsSettingFocusToUs = True Then
                '    Set controlSite = OleClientSite
                    'controlSite.OnFocus(1)
                'End If
                If InternalState.IsTbDebugging = False Then
                    On Error Resume Next
                End If
                
                'RaiseEvent EnterFocus()
                RaiseEvent GotFocus()
                        
            Case WM_KILLFOCUS
                InternalState.hasFocus = False
                'Set controlSite = OleClientSite
                'controlSite.OnFocus(0)
                
                If InternalState.IsTbDebugging = False Then
                    On Error Resume Next
                End If
                
                RaiseEvent LostFocus()
                'RaiseEvent ExitFocus()
            
            Case WM_MOUSEMOVE
                mouseEventName = "MouseMove"
            
            Case WM_LBUTTONDOWN, _
                    WM_MBUTTONDOWN, _
                    WM_RBUTTONDOWN
                mouseEventName = "MouseDown"
                setMouseCapture = True
                
                If (CanGetFocus = True) And (InternalState.hasFocus = False) Then
                    
                    Dim site As Any = CType(Of IOleInPlaceSiteWindowless)(InternalState.OleClientSite)
                    #If LOG_USERCONTROL Then
                        Log("IOleInPlaceObjectWindowless_OnWindowMessage WM_BUTTONDOWN -> site.OnUIActivate()")
                    #End If
                    
                    site.OnUIActivate()         ' by calling this now, prevents the next controlSite.OnFocus(1) call from triggering DoVerb(OLEIVERB_INPLACEACTIVATE)
                    #If LOG_USERCONTROL Then
                        Log("IOleInPlaceObjectWindowless_OnWindowMessage WM_BUTTONDOWN -> site.OnUIActivate()... DONE")
                    #End If
                    
                    If InternalState.siteFrame IsNot Nothing Then
                        #If LOG_USERCONTROL Then
                            Log("IOleInPlaceObjectWindowless_OnWindowMessage WM_BUTTONDOWN -> siteFrame.SetMenu(0, 0, 0)")
                        #End If
                        
                        On Error Resume Next
                        InternalState.siteFrame.SetMenu(0, 0, 0) ' this can throw
                        On Error GoTo 0
                        #If LOG_USERCONTROL Then
                            Log("IOleInPlaceObjectWindowless_OnWindowMessage WM_BUTTONDOWN -> siteFrame.SetMenu(0, 0, 0)... DONE")
                        #End If
                        
                    End If

                    'Dim controlSite As Any = CType(Of IOleControlSite)(InternalState.OleClientSite)
                    #If LOG_USERCONTROL Then
                        Log("IOleInPlaceObjectWindowless_OnWindowMessage WM_BUTTONDOWN -> site.SetFocus(1)")
                    #End If
                    
                    'IsSettingFocusToUs = True
                    site.SetFocus(1)
                    'IsSettingFocusToUs = False
                    #If LOG_USERCONTROL Then
                        Log("IOleInPlaceObjectWindowless_OnWindowMessage WM_BUTTONDOWN -> site.SetFocus(1)... DONE")
                    #End If
                    
                End If
            
            Case WM_LBUTTONUP, _
                    WM_MBUTTONUP, _
                    WM_RBUTTONUP
         	    mouseEventName = "MouseUp"
                releaseMouseCapture = True
            
            Case WM_LBUTTONDBLCLK, _
                    WM_MBUTTONDBLCLK, _
                    WM_RBUTTONDBLCLK
                mouseEventName = "DblClick"
                eventNeedsArgs = False
            
            Case WM_SYSKEYDOWN, _
                    WM_KEYDOWN
                shiftState = CInt(GetShiftState())
                
                If InternalState.IsTbDebugging = False Then
                    On Error Resume Next
                End If
                
                RaiseEvent KeyDown(CInt(wParam And &HFF), shiftState)
                lpResult = 0
                Exit Sub        ' consume the message
            
            Case WM_SYSKEYUP, _
                    WM_KEYUP
                shiftState = CInt(GetShiftState())
                
                If InternalState.IsTbDebugging = False Then
                    On Error Resume Next
                End If
                
                RaiseEvent KeyUp(CInt(wParam And &HFF), shiftState)
                lpResult = 0
                Exit Sub        ' consume the message
            
            Case WM_CHAR
                
                If InternalState.IsTbDebugging = False Then
                    On Error Resume Next
                End If
                
                RaiseEvent KeyPress(CInt(wParam And &HFFFF&))
                lpResult = 0
                Exit Sub        ' consume the message
        End Select
        
        If Len(mouseEventName) > 0 Then
            Dim ControlContext As Any = Me.ControlContext
            x = CLng(lParam And &HFFFF&) - InternalState.WindowlessRect.Left
            y = CLng((lParam >> 16) And &HFFFF&) - InternalState.WindowlessRect.Top
            Set targetControl = CType(Of Control)(ControlContext.RuntimeUICtxGetLightweightControlAtPosition(x, y))
            ' FIXME what about controls like Shape, do they interrupt the sequence, or does UserControl.MouseMove get called?
            If targetControl Is Nothing Then Set targetControl = Me
            
            If setMouseCapture = True Then
            	BeginWindowlessMouseCapture(targetControl)
            End If
            
            If InternalState.IsTbDebugging = False Then
                On Error Resume Next
            End If
            
            If eventNeedsArgs = True Then
                shiftState = CInt(GetShiftState())
                Dim button As Integer = 0
                
                If wParam And MK_LBUTTON Then button += CInt(vbLeftButton)
                If wParam And MK_RBUTTON Then button += CInt(vbRightButton)
                If wParam And MK_MBUTTON Then button += CInt(vbMiddleButton)

                Dim unitScale As Double = RootWindowElementBase.RuntimeUIGetUnitScale()
                Dim targetX As Long = CLng((x / unitScale) * ControlContext.RuntimeUICtxGetScaleModePixelsMultiplierX())
                Dim targetY As Long = CLng((y / unitScale) * ControlContext.RuntimeUICtxGetScaleModePixelsMultiplierY())
                RaiseEventByName(targetControl, mouseEventName, Array(shiftState, button, targetX, targetY))
            Else
                RaiseEventByName(targetControl, mouseEventName)
            End If
            
            If releaseMouseCapture = True Then
            	If EndWindowlessMouseCapture(targetControl) = True Then
                	RaiseEventByName(targetControl, "Click")
            	End If
            End If
        
            lpResult = 0
            Exit Sub        ' consume the message
        End If
        
        Dim siteWindowless As Any = CType(Of IOleInPlaceSiteWindowless)(InternalState.OleClientSite)
        siteWindowless.OnDefWindowMessage(msg, wParam, lParam, lpResult)
    End Sub
    
    Protected Sub IOleInPlaceObjectWindowlessGetDropTarget(ByRef ppDropTarget As IDropTarget) _
            Implements IOleInPlaceObjectWindowless.GetDropTarget
        # If LOG_USERCONTROL Then
            Log("IOleInPlaceObjectWindowless_GetDropTarget")
        #End If
        
        PutMemPtr(VarPtr(ppDropTarget), vbNullPtr)    ' OUT semantics                    
        Err.ReturnHResult = E_NOTIMPL
    End Sub
    
    Protected Sub ISpecifyPropertyPagesGetPages(pPages As CAUUID) _
            Implements ISpecifyPropertyPages.GetPages
        # If LOG_USERCONTROL Then
            Log("ISpecifyPropertyPages_GetPages")
        #End If
        
        'MsgBox("ISpecifyPropertyPages_GetPages")
        pPages.cElems = 0

        #If FEATURE_PROPERTYPAGE Then
        
            ' get CLSID for each property page
            Dim clsid As GUID2
            
            On Error GoTo NoPages
            Dim pagesCount As Long = UBound(PropertyPages)
            
            pPages.pElems = OLE32.OleAllocMem(LenB(Of GUID2) * (pagesCount + 1))
            
            Dim propertyPageName As String
            'Dim names As String
            For Each propertyPageName In PropertyPages
                On Error GoTo SkipPropertyPage
                'names += propertyPageName & ", "
                [_HiddenModule].RuntimeGetPropertyPageClsidByName(propertyPageName, clsid)
                
                vbaCopyBytes(16, pPages.pElems + (pPages.cElems * 16), VarPtr(clsid))
                pPages.cElems += 1
                
            '   MsgBox "PropertyPage: " & propertyPageName & ", guid: " & Hex(clsid.Guid1)
        NextPage:
            Next
            'MsgBox "GetPages: " & names
            'MsgBox "3"
        #End If
            
    NoPages:
        'MsgBox("ISpecifyPropertyPages_GetPages: " & pPages.cElems)
        Exit Sub
        
        #If FEATURE_PROPERTYPAGE Then
    SkipPropertyPage:
        Resume NextPage
        #End If
    End Sub
    
    Protected Function GetDisplayString(ByVal dispID As Long) As String _
            Implements IPerPropertyBrowsing.GetDisplayString
        'MsgBox "IPerPropertyBrowsing.GetDisplayString"
    	Err.ReturnHResult = E_NOTIMPL
    End Function
    
    Protected Sub MapPropertyToPage(ByVal dispID As Long, ByRef pClsid As GUID2) _
            Implements IPerPropertyBrowsing.MapPropertyToPage
        'MsgBox "IPerPropertyBrowsing.MapPropertyToPage"

        #If FEATURE_PROPERTYPAGE Then
            Dim SerializeInfo As SerializeInfo
            SerializeInfo.Pointer = GetClassInstanceSerializer([_HiddenModule].GetInheritedOwner(Me))
            
            'Dim outerClass As Object = GetInheritedOwner(Me) 'CType(Of ITwinBasicInternalClassSupport)([_HiddenModule].GetInheritedOwner(Me)).GetOverridenDispatchHandler()()
            Dim outerClass As Any = SerializeInfo.RuntimeUISrzGetRootClassDispatch()
            If RuntimeMapDispIdToPropertyPageClsid(outerClass, dispID, pClsid) = 0 Then
                'MsgBox "got it!"
                ' This is set via: Attribute procName.VB_ProcData.VB_Invoke_Property = "PropertyPageName"
                '   or [PropertyPage("PropertyPageName")]            
            Exit Sub
            End If
        #End If
        
        ' If fails, return CLSID_NULL
        pClsid.Guid1 = 0
        pClsid.Guid2 = 0
        Err.ReturnHResult = E_NOTIMPL
    End Sub
    
    Protected Sub GetPredefinedStrings(ByVal dispID As Long, ByRef pCaStringsOut As CALPOLESTR, ByRef pCaCookiesOut As CADWORD) _
            Implements IPerPropertyBrowsing.GetPredefinedStrings
        'MsgBox "IPerPropertyBrowsing.GetPredefinedStrings"
        Err.ReturnHResult = E_NOTIMPL
    End Sub
    
    Protected Sub GetPredefinedValue(ByVal dispID As Long, ByVal dwCookie As Long, /* out */ ByRef pVarOut As Variant) _
            Implements IPerPropertyBrowsing.GetPredefinedValue
        'MsgBox "IPerPropertyBrowsing.GetPredefinedValue"
        Err.ReturnHResult = E_NOTIMPL
    End Sub
    
    Protected Sub TranslateAccelerator(ByRef lpmsg As MSG) _
            Implements IOleInPlaceActiveObject.TranslateAccelerator
        #If LOG_USERCONTROL Then
            Log("IOleInPlaceActiveObject.TranslateAccelerator")
        #End If
        
        If (KeyPreview = True) And (lpmsg.hwnd.Value <> RootWindowElementBase.RuntimeUIGetHandle().Value) Then
            Select Case lpmsg.message
            	Case WM_KEYDOWN, _
                        WM_KEYUP, _
                        WM_CHAR
                        
                    InternalHWND.SendMessageW(lpmsg.message, lpmsg.wParam, lpmsg.lParam)
            End Select
        End If
        
        Err.ReturnHResult = S_FALSE ' we don't want to swallow the message
    End Sub
    
    Protected Sub OnFrameWindowActivate(ByVal fActivate As Long) _
            Implements IOleInPlaceActiveObject.OnFrameWindowActivate
        #If LOG_USERCONTROL Then
            Log("IOleInPlaceActiveObject.OnFrameWindowActivate")
        #End If
        
        Stop
        ' FIXME look into what VB6 does here
    End Sub
    
    Protected Sub OnDocWindowActivate(ByVal fActivate As Long) _
            Implements IOleInPlaceActiveObject.OnDocWindowActivate
        #If LOG_USERCONTROL Then
            Log("IOleInPlaceActiveObject.OnDocWindowActivate")
        #End If
        
        Stop
        ' FIXME look into what VB6 does here
    End Sub
    
    Protected Sub ResizeBorder(ByRef prcBorder As tbRECT, ByVal pUIWindow As IOleInPlaceUIWindow, ByVal fFrameWindow As Long) _
            Implements IOleInPlaceActiveObject.ResizeBorder
        #If LOG_USERCONTROL Then
            Log("IOleInPlaceActiveObject.ResizeBorder")
        #End If
        
    	Stop
        ' FIXME look into what VB6 does here
    End Sub
    
    Protected Sub EnableModeless(ByVal fEnable As Long) _
            Implements IOleInPlaceActiveObject.EnableModeless
        #If LOG_USERCONTROL Then
            Log("IOleInPlaceActiveObject.EnableModeless")
        #End If
        
        Stop
        ' FIXME look into what VB6 does here
    End Sub
    
    [Serialize(False)]
    Public Property Get Extender() As Object
        On Error Resume Next
        If InternalState.CachedExtender Is Nothing Then
            Dim controlSite As Any = CType(Of IOleControlSite)(InternalState.OleClientSite)
            Dim xtender As Object
            controlSite.GetExtendedControl(xtender)
            If xtender IsNot Nothing Then
                Set InternalState.CachedExtender = RuntimeCreateRecurseProtectedObjectWrapper(xtender)      ' Excel needs this to prevent UC.Extender.xyz from recursing to us in VBCCR (e.g. MonthView.DragIcon -> Extender.DragIcon -> MonthView.DragIcon).  FIXME We're possibly doing something wrong - need to investigate.
            
                'MsgBox "IOleObjectClose InternalState.CachedExtender-PTR: " & Hex(ObjPtr(InternalState.CachedExtender))
                'MsgBox "IOleObjectClose InternalState.CachedExtender: " & TypeName(InternalState.CachedExtender)
                
            End If
        End If
        Return InternalState.CachedExtender
    End Property
    
    Public Sub SetFocus()
        RootWindowElementBase.SetFocus()
    End Sub

    [Serialize(False)]
    Public Property Get Parent() As Object
        Return Extender.Parent
    End Property
        
    Protected Function TranslateContainerXToHimetric(ByVal containerValue As Single) As Long _
            Implements TbUserControlPrivate.TranslateContainerXToHimetric
    	Dim controlSite As Any = CType(Of IOleControlSite)(InternalState.OleClientSite)
        Dim valueOut As POINTL
        Dim valueIn As POINTF
        valueIn.x = containerValue
        controlSite.TransformCoords(valueOut, valueIn, XFORMCOORDS_CONTAINERTOHIMETRIC Or XFORMCOORDS_POSITION)
        Return valueOut.x
    End Function
    
    Protected Function TranslateContainerYToHimetric(ByVal containerValue As Single) As Long _
            Implements TbUserControlPrivate.TranslateContainerYToHimetric
    	Dim controlSite As Any = CType(Of IOleControlSite)(InternalState.OleClientSite)
        Dim valueOut As POINTL
        Dim valueIn As POINTF
        valueIn.y = containerValue
        controlSite.TransformCoords(valueOut, valueIn, XFORMCOORDS_CONTAINERTOHIMETRIC Or XFORMCOORDS_POSITION)
        Return valueOut.y
    End Function
    
    Protected Function TranslateHimetricToContainerX(ByVal himetricValue As Long) As Single _
            Implements TbUserControlPrivate.TranslateHimetricToContainerX
    	Dim controlSite As Any = CType(Of IOleControlSite)(InternalState.OleClientSite)
        Dim valueIn As POINTL
        Dim valueOut As POINTF
        valueIn.x = himetricValue
        controlSite.TransformCoords(valueIn, valueOut, XFORMCOORDS_HIMETRICTOCONTAINER Or XFORMCOORDS_POSITION)
        Return valueOut.x
    End Function
    
    Protected Function TranslateHimetricToContainerY(ByVal himetricValue As Long) As Single _
            Implements TbUserControlPrivate.TranslateHimetricToContainerY
    	Dim controlSite As Any = CType(Of IOleControlSite)(InternalState.OleClientSite)
        Dim valueIn As POINTL
        Dim valueOut As POINTF
        valueIn.y = himetricValue
        controlSite.TransformCoords(valueIn, valueOut, XFORMCOORDS_HIMETRICTOCONTAINER Or XFORMCOORDS_POSITION)
        Return valueOut.y
    End Function
    
    Protected Sub HandleBackStyleChange() _   
    	    Handles BackStyle.OnPropertyLet
            
        Me.InternalRaiseViewChanged
    End Sub

    ' Protected Sub QuickActivate(ByRef pQaContainer As QACONTAINER, ByRef pQaControl As QACONTROL) _
    '         Implements IQuickActivate.QuickActivate
        
    '     #If LOG_USERCONTROL Then
    '     Log("IQuickActivate.QuickActivate")
    '     #End If
    '     On Error Resume Next

    '     IOleObject_SetClientSite(pQaContainer.pClientSite)
    '     IViewObject_SetAdvise(1, 0, pQaContainer.pAdviseSink)
        
    '     pQaControl.cbSize = LenB(pQaControl)
    '     IOleObject_GetMiscStatus(0, pQaControl.dwMiscStatus)    ' FIXME DVA_CONTENT
    '     pQaControl.dwViewStatus = 0
    '     pQaControl.dwPropNotifyCookie = 0
    '     pQaControl.dwPointerActivationPolicy = 0
    '     pQaControl.dwEventCookie = 0
        
    '     'MsgBox Hex(pQaControl.dwMiscStatus)
    ' End Sub
    
    'Protected  Sub SetContentExtent(ByRef pSizel As SIZEL) _
    '         Implements IQuickActivate.SetContentExtent
        
    '     #If LOG_USERCONTROL Then
    '     Log("IQuickActivate.SetContentExtent")
    '     #End If
    '     IOleObject_SetExtent(1, pSizel)                          ' FIXME DVA_CONTENT
    ' End Sub
    
    ' Protected Sub GetContentExtent(ByRef pSizel As SIZEL) _
    '         Implements IQuickActivate.GetContentExtent
        
    '     #If LOG_USERCONTROL Then
    '     Log("IQuickActivate.GetContentExtent")
    '     #End If
    '     IOleObject_GetExtent(1, pSizel)                             ' FIXME DVA_CONTENT
    ' End Sub
    
    Protected Sub InternalRaiseViewChanged() _ 
            Implements ITbCommonContainerPrivate.RaiseViewChanged
        
        # If LOG_USERCONTROL Then
            Log("InternalRaiseViewChanged (0)")
        #End If
        
        If Me.InternalState.IsWindowlessActivated Then
            On Error Resume Next
            Dim siteWindowless As Any = CType(Of IOleInPlaceSiteWindowless)(InternalState.OleClientSite)
            siteWindowless.InvalidateRect(InternalState.WindowlessRect, 1)
        End If
        
        #If LOG_USERCONTROL Then
            Log("InternalRaiseViewChanged (1)")
        #End If
        
        Dim IViewObject_adviseSink As Any = Me.InternalState.IViewObject_adviseSink
        If IViewObject_adviseSink IsNot Nothing Then
            'If Me.EventsAreFrozen = False Then
                #If LOG_USERCONTROL Then
                    Log("InternalRaiseViewChanged2")
                #End If
                
                ' VBX sends OnViewChange notifications even if we're activated (i.e. when IViewObject.Draw is not being used)
                IViewObject_adviseSink.OnViewChange(DVASPECT_CONTENT, -1)
            'End If
        End If
    End Sub
    
    Protected Sub HandleUnconsumedKeyboardMessage(ByRef Msg As MSG, Consumed As Boolean) _
            Implements IWindowElementEventsUC.UnconsumedKeyboardMessage
            
        On Error Resume Next
        Dim controlSite As Any = CType(Of IOleControlSite)(InternalState.OleClientSite)
        Dim modifiers As Long = GetShiftState()
        
        controlSite.TranslateAccelerator(Msg, modifiers)
        Dim hr As Long = Err.LastHresult
        Debug.TracePrint "controlSite.TranslateAccelerator HRESULT:=" & Hex(hr)

        If hr = 0 Then
        	Consumed = True
        End If
    End Sub
    
    [Serialize(False)]
    Public Property Get ActiveControl() As Control
        Return CType(Of Control)(RootWindowElementBase.RuntimeUIGetFormActiveControl())
    End Property

    [Serialize(False)]
    Public Property Get Count() As Long
        Return CLng(Me.Controls.Count)
    End Property
            
    [Unimplemented]
        Public Function Point(ByVal X As Single, ByVal Y As Single) As Long
        End Function
                
    [Enumerator]
    Public Function InternalEnumerator() As stdole.IUnknown     ' FIXME should not be exposed
        Return CallByDispId(Me.Controls, -4, vbGet)
    End Function
    
    [Serialize(False)]
    [Description("")]
    Property Get CanGetFocus() As Boolean
        Return InternalBaseControlInfo.CanGetFocus
    End Property
    
    [Serialize(False)]
    [Description("")]
    Property Let CanGetFocus(ByVal Value As Boolean)
        InternalBaseControlInfo.CanGetFocus = Value
    End Property
    
    Protected Sub RaiseChange() _
            Implements ITbCommonContainerPrivate.RaiseChange
    End Sub
    
    Protected Sub RebuildMenus(ByVal IsRuntimeChange As Boolean) _
               Implements ITbCommonContainerPrivate.RebuildMenus
    End Sub
    
    Protected Sub BuildMenus(existingMenuHandle As HMENU, windowListMenu As LongPtr, Container As Control, Level As Long, IsPopUp As Boolean, BoldMenuItem As Menu) _
               Implements ITbCommonContainerPrivate.BuildMenus
    End Sub
    
    Protected Sub SyncPictureINIT()
        Dim tempPicture As StdPicture
        CommonLoadPictureInit(tempPicture, Me.PictureINIT)
        InternalChangePicture(tempPicture)
    End Sub
    
    Protected Sub DesignerArrayFieldUpdated(ByVal FieldName As String) _
            Implements ITwinBasicDesignerExtensions2.DesignerArrayFieldUpdated
        Set Picture = Nothing
        SyncPictureINIT()
    End Sub
    
    Protected Sub HandlePreInitialize() _
            Implements IWindowsControl.PreInitialize
        ' This event fires once the UserControl has been event-registered into its outer class

        Dim SerializeInfo As SerializeInfo
        SerializeInfo.Pointer = GetClassInstanceSerializer([_HiddenModule].GetInheritedOwner(Me))
        
        ' We could handle this better if we had full inheritance support
        ' This is needed to make properties on the outer interface accessible at design time in property lists etc.
        Dim rootObject As Any = SerializeInfo.RuntimeUISrzGetRootClassDispatch()
        SetClassOverrideDispatch([_HiddenModule].GetInheritedOwner(Me), rootObject)
        'CType(Of ITwinBasicInternalClassSupport)(Me).OverrideDispatchHandler rootObject  ' this causes a circular reference that needs to be manually broken in IOleObject_Close

        'Debug.TracePrint "RefCount: " & GetClassInstanceRefCount(Me)
        
        ' This is where VB6 raises this event, i.e. before any HWND creation, and before any OLE integration etc.
        'Debug.Print "IInitializeControl_PreInitialize"
        RaiseEvent Initialize()
    End Sub
            
    Protected Sub EnumObjects(ByVal grfFlags As Long, ppenum As IEnumUnknown) _
            Implements IOleContainer.EnumObjects

'        Debug.Print "IOleContainer_EnumObjects"
        PutMemPtr(VarPtr(ppenum), vbNullPtr)    ' OUT semantics                    
        
        Set ppenum = CType(Of IEnumUnknown)(RootWindowElementBase.RuntimeUICreateControlsEnumerator(grfFlags, 4))
    End Sub
    
    Protected Sub LockContainer(ByVal fLock As Long) _
            Implements IOleContainer.LockContainer
        
'        Debug.Print "IOleContainer_LockContainer"
    End Sub
    
    Protected Sub ParseDisplayName(ByVal pbc As stdole.IUnknown, ByVal pszDisplayName As LongPtr, pchEaten As Long, ppmkOut As VBRUN.tbInternal_IMoniker) _
            Implements IOleContainer.ParseDisplayName
        
        PutMemPtr(VarPtr(ppmkOut), vbNullPtr)    ' OUT semantics                    
        
'        Debug.Print "IOleContainer_ParseDisplayName"
    End Sub
    
    Protected Sub BorderStyleChanged() _  
            Handles BorderStyle.OnPropertyLet
                
        InternalChangedBorder()
    End Sub
    
    Function OnGetBorderSize() As Long _
            Overrides GraphicsBase.OnGetBorderSize
        Dim RetVal As Long
        If BorderStyle = ControlBorderStyleConstants.vbFixedSingleBorder Then
            RetVal += 1 ' 1 pixel either side   
            If Appearance = VBRUN.AppearanceConstants.vbAppear3d Then
                RetVal += 1 ' a further 1 pixel either side     
            End If
        End If
        Return RetVal
    End Function
    
    Protected Function OnGetControlType() As ControlTypeConstants _
            Overrides GraphicsBase.OnGetControlType
        Return ControlTypeConstants.vbUserControl
    End Function
    
    ' Implements ICategorizeProperties              ' just for test
    ' Protected Sub ICategorizeProperties_MapPropertyToCategory(ByVal dispID As Long, categoryID As Long)
    '     categoryID = -3     ' Font
    ' End Sub
    ' Protected Sub ICategorizeProperties_GetCategoryName(ByVal propcat As Long, ByVal lcid As Long, categoryName As String)
    '     categoryName = "Font123"
    ' End Sub
    
End Class

[WindowsControl("/miscellaneous/ICONS??/Frame??.png")]
[ClassId("33AD5010-6699-11CF-B70C-00AA0060D393")]
[InterfaceId("9D6977D6-0C4E-418D-A5F2-3AFFDB1F49A2")]    ' FIXME implement {33AD5011-6699-11CF-B70C-00AA0060D393} for backcompat
' WARNING: above InterfaceId is referred to as IID_ITBUserControl in tB Sources
[COMCreatable(False)]
[COMExtensible(True)]
[EventsUseDispInterface]
[ComImport(True)]
Class UserControl
    Inherits UserControlBaseCtl

    Protected Sub Class_BeforeFirstMethodAccess()
        ' If Me.Extender IsNot Nothing Then
        '     Debug.Print Me.Extender.Name & "." & CurrentProcedureName & " *** UC"
        ' Else
        '     Debug.Print CurrentComponentName & "." & CurrentProcedureName & " *** UC"
        ' End If
    'Stop
            
        If IsTerminating = True Then Exit Sub

        If InternalState.IsLoaded = False Then
            DoLoadNow()
        End If
    End Sub
        
    Protected Sub DoLoadNow()
        ' for the Initialize event, there's no need to have the final size of the control
        ' the ScaleWidth/Height etc should be based off the design-time size of the designed control
        'Stop
        If InternalState.DoLoadNowProcessed = True Then
            Exit Sub
        End If
        InternalState.DoLoadNowProcessed = True
        
        InternalState.MutedResizeEventsCount += 1
            Debug.TracePrint "InitializeMe.2"
                    
            'Debug.Print "UC.InitializeMe EnsureContainerIsLoaded(STARTING)"
            InternalState.IsCreatingWindow = True
            [_HiddenModule].EnsureContainerIsLoaded(Me)
            InternalState.IsCreatingWindow = False
                    
            Debug.TracePrint "InitializeMe.2 [DONE]"
                    
            If InternalState.IsLoaded Or InternalState.IsDesignMode Then
                'Debug.Print "UC.InitializeMe EnsureContainerIsLoaded(DONE)"
                'ControlContext.EnsureContainerIsLoaded
                Debug.TracePrint "InitializeMe.3"
                                
                Dim RootWindowElementBase As Any = Me.RootWindowElementBase
                #If LOG_USERCONTROL Then
                    Log("InitializeMe (1)")
                #End If
                                
                Debug.TracePrint "InitializeMe.4"
                SyncScaleMode(Me, RootWindowElementBase)

                Debug.TracePrint "InitializeMe.5"
                InternalChangeHDC(0, RootWindowElementBase.RuntimeUIGetHandle(), RootWindowElementBase, Me.Picture, Me, False)
                #If LOG_USERCONTROL Then
                    Log("InitializeMe (2)")
                #End If
                                
                Debug.TracePrint "InitializeMe.6"
            End If
                    
            Debug.TracePrint "InitializeMe.7"
                    
        InternalState.MutedResizeEventsCount -= 1
    End Sub

End Class
#End If