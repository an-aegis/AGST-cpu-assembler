#If FEATURE_FILELISTBOX Then
[ClassId("0FAF49DB-0223-47D2-AD90-0D185EE559B6")]
[InterfaceId("35A912CF-B9BC-45F9-9216-9C37B34EE932")]  ' FIXME implement {33AD4F61-6699-11CF-B70C-00AA0060D393} for backcompat
[COMCreatable(False)]
[EventsUseDispInterface]
[ComImport(True)]
Private Class FileListBoxBaseCtl

    #Region "INHERITANCE"

        Inherits BaseControlFocusable
        
        [WithDispatchForwarding] Implements Control
        Implements IWindowsControl
        Implements IWindowElementEventsCommon
         
    #End Region
        
    #Region "STATE"
    
        [Description("")]
            Public BorderStyle As VBRUN.ControlBorderStyleConstants = ControlBorderStyleConstants.vbFixedSingleBorder
        [CustomDesigner("designer_SpectrumWindows")]
        [Description("")]
            Public BackColor As OLE_COLOR = VBRUN.SystemColorConstants.vbWindowBackground
        [CustomDesigner("designer_SpectrumWindows")]
        [Description("")]
            Public ForeColor As OLE_COLOR = VBRUN.SystemColorConstants.vbWindowText
        [Description("")]
            Public Archive As Boolean = True
        [Description("")]
            Public Hidden As Boolean
        [Description("")]
            Public Normal As Boolean = True
        [Description("")]
            Public ReadOnly As Boolean = True
        [Description("")]
            Public System As Boolean
        [Description("")]
            Public MultiSelect As MultiSelectConstants = MultiSelectConstants.vbMultiSelectNone
        [Description("")]
            Public Pattern As String = "*.*"
              
        [Description("VB6 doesn't trigger the Scroll event for mouse-wheel events.  Set this to True to generate Scroll events in response to mouse-wheel notifications")]
            Public WheelScrollEvent As Boolean = True

        [Description("")]
            Public IntegralHeight As Boolean = True

        [Serialize(False)]
        [Description("")]
            Public Path As String

            Protected CachedTopIndex As Long
            Protected IsInitializing As Boolean
            #If FEATURE_OLEDRAGDROP Then
            Protected OLEDragDropHandler As OLEDragDropHandler
            #End If
            Protected IsRefreshing As Boolean
            Protected CachedPattern As String
            Protected CachedPath As String
            Protected MouseDownNeedsManualRelease As Boolean
                        
        [Description("Opacity, given as a percentage, 0 - 100.  REQUIRES TARGET OS 6.2+ FOR CHILD CONTROLS.")]
            Public Opacity As Double = 100
        
        [CustomDesigner("designer_SpectrumWindowsOrClear")]
        [Description("A color, when set, that will appear fully transparent in the window.  REQUIRES TARGET OS 6.2+ FOR CHILD CONTROLS.")]
            Public TransparencyKey As OLE_COLOR = -1
                
        #If FEATURE_OLEDRAGDROP Then
        Public OLEDragMode As VBRUN.OLEDragConstants
        
        [CustomDesigner("designer_RestrictedOLEDropMode")]
            Public OLEDropMode As VBRUN.OLEDropConstants
        
        Public Sub OLEDrag()
            CommonOLEDrag(Me)
        End Sub
        #End If
               
        #If FEATURE_HELP Then
        Public HelpContextID As Long
        Public WhatsThisHelpID As Long
        Public Sub ShowWhatsThis()
            HelpSystem.ShowControlHelpManual(Me)
        End Sub
        #end If
            
    #End Region

    #Region "EVENTS"
    
        [DefaultDesignerEvent]
        [Description("")]
        [DispId(&HEAEA0004)]
            Event Click()
        [Description("")]
        [DispId(&HEAEA0005)]
            Event DblClick()
        [Description("")]
            Event PathChange()
        [Description("")]
            Event PatternChange()
        [Description("")]
        [DispId(&HEAEA0006)]
            Event GotFocus()
        [Description("")]
        [DispId(&HEAEA0008)]
            Event KeyDown(KeyCode As Integer, Shift As Integer)
        [Description("")]
        [DispId(&HEAEA0009)]
            Event KeyPress(KeyAscii As Integer)
        [Description("")]
        [DispId(&HEAEA000A)]
            Event KeyUp(KeyCode As Integer, Shift As Integer)
        [Description("")]
        [DispId(&HEAEA0001)]
            Event MouseDown(Button As Integer, Shift As Integer, X As Single, Y As Single)
        [Description("")]
        [DispId(&HEAEA0002)]
            Event MouseMove(Button As Integer, Shift As Integer, X As Single, Y As Single)
        [Description("")]
        [DispId(&HEAEA0003)]
            Event MouseUp(Button As Integer, Shift As Integer, X As Single, Y As Single)
        [Description("")]
        [DispId(&HEAEA0007)]
            Event LostFocus()
        [Description("")]
            Event Initialize()
            
        [Description("")]
        [DispId(&HEAEA000B)]
            Event DragDrop(Source As Control, X As Single, Y As Single)
        [Description("")]
        [DispId(&HEAEA000C)]
            Event DragOver(Source As Control, X As Single, Y As Single, State As Integer)
        Event OLECompleteDrag(Effect As Long)
        Event OLEDragDrop(Data As DataObject, Effect As Long, Button As Integer, Shift As Integer, X As Single, Y As Single)
        Event OLEDragOver(Data As DataObject, Effect As Long, Button As Integer, Shift As Integer, X As Single, Y As Single, State As Integer)
        Event OLEGiveFeedback(Effect As Long, DefaultCursors As Boolean)
        Event OLESetData(Data As DataObject, DataFormat As Integer)
        Event OLEStartDrag(Data As DataObject, AllowedEffects As Long)
        [DispId(&HEAEA000D)]
            Event Validate(Cancel As Boolean)
        Event Scroll()

    #End Region

    #Region "MEMBERS"
        Sub New()
            BaseControlFocusable.New(ControlTypeConstants.vbFileListBox)
        End Sub
    
        #If LOG_TERMINATE Then
            Protected Sub Class_Terminate()
                    Debug.Print CurrentComponentName & "." & CurrentProcedureName
            End Sub
        #End If
            
        Protected Sub HandleLoad() _
                Implements IWindowElementEventsCommon.Load
            
            Dim Opacity As Any = Me.Opacity
            If ((Opacity >= 0) And (Opacity < 100)) Or (TransparencyKey <> -1) Then
                SyncOpacity
            End If
        End Sub
        
        Protected Sub SyncOpacity() _ 
                Handles Opacity.OnPropertyLet, _
                        TransparencyKey.OnPropertyLet
            
            RootWindowElementBase.RuntimeUIGetHandle().CommonSyncOpacity(Me.TransparencyKey, Me.Opacity)
        End Sub
        
        Protected Sub HandleInitialize(ByVal ControlContext As ControlContext) _
                Implements IWindowsControl.Initialize
                
            Me.InternalStateReset()     ' resets all the base class state
            Me.Path = vbNullString
            Me.CachedTopIndex = 0
            Me.IsInitializing = True
            Me.IsRefreshing = False
            Me.CachedPattern = vbNullString
            Me.CachedPath = vbNullString
            Me.MouseDownNeedsManualRelease = False
            
            Dim SerializeInfo As Any = ControlContext.RuntimeUICtxGetSerializer()
            
            If Not SerializeInfo.RuntimeUISrzDeserialize(Me) Then
                'Caption_INIT = "FileListBox"
            End If
            'IsDesignMode = .IsDesignMode
            
            Dim Opacity As Any = Me.Opacity
            If Opacity > 100 Then Me.Opacity = 100
            If Opacity < 0 Then Me.Opacity = 0
            
            Dim styles As Long = GetStyles()
            Dim extendedStyles As Long
                
                extendedStyles += If(ControlContext.RuntimeUICtxIsPlacedOnUserControl(), 0&, WS_EX_NOPARENTNOTIFY)
                If Me.BorderStyle = ControlBorderStyleConstants.vbFixedSingleBorder Then
                    If BaseControlFocusable.Appearance = AppearanceConstants.vbAppear3d Then
                        extendedStyles += WS_EX_CLIENTEDGE
                    End If
                End If
                
            Dim InitData As WindowCreationData
            InitData.WindowAtomIdx = CInt(EnumWindowAtoms.AtomIdx_ThunderFileListBox)
            InitData.Caption = ""
            InitData.WindowStyles = styles
            InitData.ExtendedStyles = extendedStyles
            InitData.Flags = NeedsPrePostMessages Or _
                                ForwardGotFocus Or _
                                ForwardLostFocus Or _
                                ForwardKeyDown Or _
                                ForwardKeyUp Or _
                                ForwardKeyPress Or _
                                ForwardMouseMove Or _
                                ForwardMouseUp Or _
                                ForwardDragOver Or _
                                ForwardValidate
            CreateRootWindowElement(ControlContext, InitData)
            RootWindowElementBase.RuntimeUISetAndSinkEvents(Me)
        End Sub
        
        Protected Function GetStyles() As Long
            Dim styles As Long = ListBoxStyles.LBS_NOTIFY + _
                        ListBoxStyles.LBS_SORT + _
                        CLng(WS_VSCROLL) + _
                        If(Me.IntegralHeight, 0&, ListBoxStyles.LBS_NOINTEGRALHEIGHT)
            
            If Me.BorderStyle = ControlBorderStyleConstants.vbFixedSingleBorder Then
                If BaseControlFocusable.Appearance = AppearanceConstants.vbAppear3d Then
                Else
                    styles += WS_BORDER
                End If
            End If
            
            Dim lbStyles As Long
            Select Case Me.MultiSelect
                Case MultiSelectConstants.vbMultiSelectSimple: lbStyles = ListBoxStyles.LBS_MULTIPLESEL
                Case MultiSelectConstants.vbMultiSelectExtended: lbStyles = ListBoxStyles.LBS_EXTENDEDSEL
            End Select
            
            Return styles + lbStyles
        End Function
        
        Protected Sub HandleGetColors(ByVal hdc As HDC, ByRef BackBrushOut As LongPtr, ByVal ControlType As ControlTypeConstants) _
                Implements IWindowElementEventsCommon.GetColors
                
            HandleGetColorsCommon(hdc, BackBrushOut, Me)
        End Sub
        
        Protected Sub HandleDestroy() _
                Implements IWindowsControl.Destroy
                
            #If LOG_TERMINATE Then
                Debug.Print CurrentComponentName & "." & CurrentProcedureName
            #End If
            ' disconnect anything that causes a circular reference here
            Set Me.Font = Nothing
        
            [_HiddenModule].ResetFirstMethodAccessFlag([_HiddenModule].GetInheritedOwner(Me))
        End Sub
        
        Protected Sub HandleCreate() _
                Implements IWindowElementEventsCommon.Create
            
            'Debug.Print "FileListBox HWND: " & Hex(Me.hWnd)
            ' Set the font into the control first.  If IntegralHeight is active, then the control will adjust accordingly.
            SyncFontProperties()
            If Me.IntegralHeight Then
                Me.InternalSyncHeight()
            End If
                        
            Me.Path = App.Path
            SyncFiles()
            #If FEATURE_OLEDRAGDROP Then
            SyncOLEDropMode()
            #End If
            
            RaiseEvent Initialize()
            IsInitializing = False
        End Sub
        
        Protected Sub SyncRecreate() _
                Handles MultiSelect.OnPropertyLet, _
                        IntegralHeight.OnPropertyLet
                
            Dim TopIndex As Long = Me.TopIndex
            Dim Path As String = Me.Path
            Dim ListIndex As Long = Me.ListIndex
            RecreateWindow(GetStyles())
            Me.Path = Path
            SyncFiles()
            Me.TopIndex = TopIndex
            If ListIndex <> -1 Then Me.ListIndex = ListIndex
        End Sub
        
        Option Compare Text     ' Important for the Like comparison to work without case sensitivity.
        Sub SyncFiles()
        	
            If IsRefreshing = True Then Exit Sub
            IsRefreshing = True
                        
            If Left(Me.Path, 4) = "\\?\" Then Me.Path = Right$(Me.Path, Len(Me.Path) - 4)
            
            If Right(Me.Path, 1) <> "\" Then Me.Path += "\"
            If Me.Pattern = "" Then Me.Pattern = "*.*"
            
            On Error GoTo InvalidPath
            
                Dim Hidden As Any = Me.Hidden
                Dim System As Any = Me.System
                                
                Dim NotFlags As Long = If(Me.Archive, 0&, VbFileAttribute.vbArchive) + _
                            If(Hidden, 0&, VbFileAttribute.vbHidden) + _
                            If(Me.ReadOnly, 0&, VbFileAttribute.vbReadOnly) + _
                            If(System, 0&, VbFileAttribute.VbSystem)
                
                Dim InclusionFlags As VbFileAttribute = If(Hidden, vbHidden, 0&) + _
                                    If(System, VbSystem, 0&)
                
                Dim HideFilesWithNoAttributes As Boolean
                If Me.Normal = False Then HideFilesWithNoAttributes = True
                
                Dim Path As Any = Me.Path
                ' Before emptying the list, first check the path is valid...
                If (GetAttr(Path) And vbDirectory) = 0 Then Err.Raise 76
                                
                SendMessageCtl(ListBoxMessages.LB_RESETCONTENT, 0, 0)
                CachedPath = Path
                Dim Pattern As Any = Me.Pattern
                CachedPattern = Pattern
 
                Dim splitPattern As Variant = Split(Pattern, ";")
                Dim _pattern As Variant
                
                On Error Resume Next
                Dim currentItem As String = Dir(Path & "*.*", InclusionFlags)
                If Len(currentItem) = 0 Then Err.Raise 76

                While Len(currentItem) > 0
                    If (currentItem <> ".") And (currentItem <> "..") Then
                    	Dim attribs As Long = GetAttr(Path & currentItem)
                        If (attribs And NotFlags) = 0 Then
                            If HideFilesWithNoAttributes = False Or attribs <> 0 Then
                                For Each _pattern In splitPattern
                                    If currentItem Like _pattern Then
                                        RootWindowElementBase.CommonListboxAddOrInsert(currentItem)
                                        Exit For
                                    End If
                                Next
                                '    ItemData(Me.ListCount - 1) = Me.DirLevel
                            End If
                        End If
                    End If
                    currentItem = Dir()
                Wend
                        
        ExitCleanup:
            IsRefreshing = False
            
            If Len(Me.Path) > 3 Then Me.Path = Left$(Me.Path, Len(Me.Path) - 1)     ' remove trailing \, except for drives
            If Len(CachedPath) > 3 Then CachedPath = Left$(CachedPath, Len(CachedPath) - 1)     ' remove trailing \, except for drives
            Exit Sub
            
        InvalidPath:
            Err.Raise 76, , "Path not found"
            Resume ExitCleanup

        End Sub
        
        [Serialize(False)]
        Public Property Get SelCount() As Long
            Return CLng(SendMessageCtl(ListBoxMessages.LB_GETSELCOUNT, 0, 0))
        End Property
        
        #If FEATURE_OLEDRAGDROP Then
        Protected Sub HandlePreMouseDown(ByVal Button As VBRUN.MouseButtonConstants, _
                                        ByVal ShiftState As VBRUN.ShiftConstants, _
                                        ByVal X As Single, ByVal Y As Single, _
                                        ByRef SwallowMessage As Boolean) _
                Implements IWindowElementEventsCommon.PreMouseDown
            
            If OLEDragMode = vbOLEDragAutomatic Then
            	Dim itemIndex As Long = RootWindowElementBase.CommonListBoxPreMouseDownHandleOLEDragDetect(Me.ControlContext, MouseDownNeedsManualRelease, Me.ListIndex, X, Y)
                If itemIndex <> -1 Then
                    Dim rootPath As String = Me.Path
                    If Right(rootPath, 1) <> "\" Then rootPath += "\"
                    Dim setValue As Variant
                    If Me.MultiSelect Then
                        setValue = RootWindowElementBase.CommonGetSelectedItemsAsDelimitedString(rootPath)
                    Else
                        setValue = rootPath & List(itemIndex)
                    End If
                    #If FEATURE_OLEDRAGDROP Then
                    CommonOLEDrag(Me, setValue, True, False)
                    #End If
                    SwallowMessage = True
                End If
            End If
        End Sub
        #End If
            
        Protected Sub HandleMouseDown(ByVal Button As VBRUN.MouseButtonConstants, _
                                        ByVal ShiftState As VBRUN.ShiftConstants, _
                                        ByVal X As Single, ByVal Y As Single) _
                Implements IWindowElementEventsCommon.MouseDown
                
            RaiseEvent MouseDown(CInt(Button), CInt(ShiftState), X, Y)
            
            If MouseDownNeedsManualRelease = True Then
                MouseDownNeedsManualRelease = False
                USER32.ReleaseCapture()
                RaiseEvent MouseUp(CInt(Button), CInt(ShiftState), X, Y)
            End If
        End Sub
        
        Protected Sub HandleCommand(ByVal NotificationCode As ListBoxNotifications, _
                                    ByVal Identifier As Integer, ByRef Handled As Boolean) _
                Implements IWindowElementEventsCommon.Command
                
            Select Case NotificationCode
                Case ListBoxNotifications.LBN_SELCHANGE
                    CheckTopIndexChanged()
                    RaiseEvent Click()
                    Handled = True
                Case ListBoxNotifications.LBN_SELCANCEL
                    RaiseEvent Click()
                    Handled = True
                Case ListBoxNotifications.LBN_DBLCLK
                    RaiseEvent DblClick
                    Handled = True
            End Select
        End Sub
                
        [Hidden]
        Public Sub AddItem(ByVal Value As String, Optional ByVal Index As Variant)
            Err.Raise 438
        End Sub
        
        [Hidden]
        Public Sub RemoveItem(ByVal Index As Variant)
            Err.Raise 438
        End Sub
        
        [Hidden]
        Public Sub Clear()
            Err.Raise 438
        End Sub
        
        [Serialize(False)]
        Public Property Get List(ByVal Index As Long) As String
        	Return RootWindowElementBase.CommonGetListBoxStringByIndex(Index)
        End Property

        [Serialize(False)]
        Public Property Get ListCount() As Long
            Return CLng(SendMessageCtl(ListBoxMessages.LB_GETCOUNT, 0, 0))
        End Property
        
        [Serialize(False)]
        Public Property Get TopIndex() As Long
            Return CLng(SendMessageCtl(ListBoxMessages.LB_GETTOPINDEX, 0, 0))
        End Property
        
        [Serialize(False)]
        Public Property Let TopIndex(ByVal Value As Long)
            SendMessageCtl(ListBoxMessages.LB_SETTOPINDEX, Value, 0)
        End Property
        
        [Serialize(False)]
        Public Property Get ListIndex() As Long
            Return CLng(SendMessageCtl(ListBoxMessages.LB_GETCURSEL, 0, 0))
        End Property
        
        [Serialize(False)]
        Public Property Let ListIndex(ByVal Value As Long)
            If Me.ListIndex <> Value Then
            SendMessageCtl(ListBoxMessages.LB_SETCURSEL, Value, 0)
            End If
        End Property
        
        [Serialize(False)]
        Public Property Get FileName() As String
            If Me.ListIndex = -1 Then Exit Property
            Return Me.List(Me.ListIndex)
        End Property
        
        [Serialize(False)]
        Public Property Let FileName(ByVal Value As String)
            Dim index As Long = CLng(SendMessageCtl(LB_FINDSTRINGEXACT, -1, StrPtrSafe(Value)))
            If index <> -1 Then
                Me.ListIndex = index
            End If
        End Property
        
        [Serialize(False)]
        [DefaultMember]
        Public Property Get _Default() As String
            Return FileName
        End Property
        
        [Serialize(False)]
        [DefaultMember]
        Public Property Let _Default(Value As String)
            FileName = Value
        End Property
        
        [Serialize(False)]
        Protected Sub HandlePathChange() _
                Handles Path.OnPropertyLet
            If Mid(Path, 2, 1) = ":" Then
                If Len(Path) = 2 Then
                    ' Change of path is ignored.
                    Path = CachedPath
                    Exit Sub
                End If
            End If
            
            If (Len(Path) > 3) AndAlso (Right(Path, 1) = "\") Then Path = Left$(Path, Len(Path) - 1)     ' remove trailing \, except for drives
            
            If Path = CachedPath Then Exit Sub
            SyncFiles()
            RaiseEvent PathChange()
        End Sub
        
        [Serialize(False)]
        Public Property Get PathWithBackslash() As String
            Dim retVal As String = Path
            If Right(retVal, 1) <> "\" Then retVal += "\"
            Return retVal
        End Property
        
        [Serialize(False)]
        Protected Sub HandlePatternChange() _
                Handles Pattern.OnPropertyLet
                
            If Pattern = CachedPattern Then Exit Sub
            SyncFiles()
            RaiseEvent PatternChange()
        End Sub
        
        [Serialize(False)]
        Protected Sub HandleAttributesChange() _
                Handles Archive.OnPropertyLet, _
                        Hidden.OnPropertyLet, _
                        Normal.OnPropertyLet, _
                        ReadOnly.OnPropertyLet, _
                        System.OnPropertyLet
                        
            SyncFiles()
            RaiseEvent PatternChange()
        End Sub
                
        Protected Sub ColorsChanged() _
                Handles BackColor.OnPropertyLet, _
                        ForeColor.OnPropertyLet
            
            Me.Refresh
        End Sub
        
        Public Sub Refresh()
            Me.SyncFiles()
            RootWindowElementBase.CommonRedrawEraseInvalidate()
        End Sub
        
        [Serialize(False)]
        Public Property Get Selected(ByVal Index As Long) As Boolean
            Return SendMessageCtl(ListBoxMessages.LB_GETSEL, Index, 0)
        End Property
        
        [Serialize(False)]
        Public Property Let Selected(ByVal Index As Long, ByVal NewValue As Boolean)
            If Selected(Index) <> NewValue Then
                If Me.MultiSelect = vbMultiSelectNone Then
                    SendMessageCtl(ListBoxMessages.LB_SETCURSEL, Index, 0)
                Else
                    SendMessageCtl(ListBoxMessages.LB_SETSEL, If(NewValue, 1, 0), Index)
                End If
                RaiseEvent Click()
            End If
        End Property
        
        [Serialize(False)]
        Public Property Get Parent() As Object ' As Form  FIXME, needs to work also for UCs
            Return ControlContext.RuntimeUICtxEnsureGetForm()
        End Property

        Protected Sub BorderStyleChanged() _  
        	    Handles BorderStyle.OnPropertyLet
                
            CommonSyncBorderStyle(Me)
        End Sub
        
        Protected Function CheckTopIndexChanged() As Boolean
            Dim topIndex As Long = Me.TopIndex
            If CachedTopIndex <> topIndex Then
                CachedTopIndex = topIndex
                RaiseEvent Scroll
                Return True
            End If
            Return False
        End Function

        Protected Sub PostProcessMessage(ByVal hwnd As LongPtr, ByVal Message As Long, ByVal wParam As LongPtr, ByVal lParam As LongPtr, ByRef ReturnValue As LongPtr, ByVal PostMessageCookie As Long) _
                Implements IWindowElementEventsCommon.PostProcessMessage

            Select Case Message
                Case ListBoxMessages.LB_SETTOPINDEX
                    CheckTopIndexChanged()
            End Select
        End Sub
        
        Protected Sub HandleScroll(ByVal ScrollType As SCROLLNOTIFY, ByVal IsHorizontal As Boolean) _
                Implements IWindowElementEventsCommon.Scroll
             
            If IsHorizontal = False Then
                If RootWindowElementBase.CommonHandleVerticalScroll(ScrollType, Me.ListCount) = True Then
                    Dim Value As Long = RootWindowElementBase.GetScrollValue(SB_VERT)
                    SendMessageCtl(ListBoxMessages.LB_SETTOPINDEX, Value, 0)
                End If
            End If
            'CheckTopIndexChanged()
        End Sub
        
        Protected Sub HandleWheel(ByVal Delta As Integer, ByVal Horizontal As Boolean) _
                Implements IWindowElementEventsCommon.MouseWheel
                
            If Horizontal = False Then
                If WheelScrollEvent Then CheckTopIndexChanged()
            End If
        End Sub
                
        #If FEATURE_OLEDRAGDROP Then
        Protected Sub SyncOLEDropMode() _
                Handles OLEDropMode.OnPropertyLet
                
            BaseSyncOLEDropMode(Me, Me.OLEDropMode, Me.OLEDragDropHandler, False, False)
        End Sub
        #endif
        
        Public Function SelectedIndices() As Collection
            Return CommonGetSelectedIndices(RootWindowElementBase.RuntimeUIGetHandle())
        End Function
    #End Region
    
End Class

[Description("A Win32 native FileListBox")]
[WindowsControl("/miscellaneous/ICONS??/FileListBox??.png")]
[ClassId("33AD4F60-6699-11CF-B70C-00AA0060D393")]
[InterfaceId("EC734189-8A9A-4FFA-85F3-4795FB07AEAB")]  ' FIXME implement {33AD4F61-6699-11CF-B70C-00AA0060D393} for backcompat
[COMCreatable(False)]
[EventsUseDispInterface]
[ComImport(True)]
Class FileListBox
    Inherits FileListBoxBaseCtl
    
    Protected Sub Class_BeforeFirstMethodAccess()
        [_HiddenModule].EnsureContainerIsLoaded(Me)
    End Sub
End Class
#End If